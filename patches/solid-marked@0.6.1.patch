diff --git a/README.md b/README.md
index feabb42797f902e4e844f50754925f51c143bea1..843aa1f4aa160f270ad3a2abc7a7ffeb98e182b0 100644
--- a/README.md
+++ b/README.md
@@ -671,7 +671,7 @@ Let's take this example code:
     return (
       <Dynamic component={_ctx$.builtins.Root}>
         <Dynamic component={_ctx$.builtins.Paragraph}>
-          <Dynamic component={typeof Example === 'undefined' ? __ctx.components.Example : Example}>
+          <Dynamic component={typeof Example === 'undefined' ? _ctx$.components.Example : Example}>
             Hello World
           </Dynamic>
         </Dynamic>
diff --git a/dist/cjs/development/compiler.cjs b/dist/cjs/development/compiler.cjs
index 13119480fa5ca790b7e700a8017344e53ae4ba26..faf5cc9a4676e4f80bf42822699450dae746889b 100644
--- a/dist/cjs/development/compiler.cjs
+++ b/dist/cjs/development/compiler.cjs
@@ -151,12 +151,12 @@ function createJSXTag(ctx, nodeName) {
     return nodeName;
   }
   if (/^[a-zA-Z0-9]+(-[a-zA-Z0-9]+)+$/.test(nodeName)) {
-    return `__ctx.components['${nodeName}']`;
+    return `_ctx$.components['${nodeName}']`;
   }
   if (/^[a-zA-Z0-9]+:[a-zA-Z0-9]+$/.test(nodeName)) {
-    return `__ctx.components['${nodeName}']`;
+    return `_ctx$.components['${nodeName}']`;
   }
-  return `typeof ${nodeName} === 'undefined' ? __ctx.components.${nodeName} : ${nodeName}`;
+  return `typeof ${nodeName} === 'undefined' ? _ctx$.components.${nodeName} : ${nodeName}`;
 }
 var CTX_VAR = "_ctx$";
 var MARKUP = {
diff --git a/dist/cjs/development/compiler.cjs.map b/dist/cjs/development/compiler.cjs.map
index 7a3a161a5c0b2c116e556e336144022aaad4b7de..b7bc9cba435474cee0a1bbce38b2177756808323 100644
--- a/dist/cjs/development/compiler.cjs.map
+++ b/dist/cjs/development/compiler.cjs.map
@@ -1,7 +1,7 @@
 {
   "version": 3,
   "sources": ["../../../compiler/index.ts", "../../../compiler/compiler.ts", "../../../compiler/string.ts"],
-  "sourcesContent": ["import type { RawSourceMap } from 'source-map';\nimport {\n  SourceNode,\n} from 'source-map';\nimport {\n  fromMarkdown,\n} from 'mdast-util-from-markdown';\nimport { mdxFromMarkdown } from 'mdast-util-mdx';\nimport { gfmFromMarkdown } from 'mdast-util-gfm';\nimport { frontmatterFromMarkdown } from 'mdast-util-frontmatter';\nimport { toc } from 'mdast-util-toc';\nimport { mdxjs } from 'micromark-extension-mdxjs';\nimport { gfm } from 'micromark-extension-gfm';\nimport { frontmatter } from 'micromark-extension-frontmatter';\nimport GithubSlugger from 'github-slugger';\nimport { CTX_VAR, compileNode } from './compiler';\nimport type { Options, StateContext } from './types';\n\nexport type { Options } from './types';\nexport * from './interfaces';\n\nconst USE_MDX_VAR = '_useMDX$';\n\nexport interface Result {\n  code: string;\n  map: RawSourceMap;\n}\n\nexport function compile(\n  fileName: string,\n  markdownCode: string,\n  options: Options = {},\n): Result {\n  const ast = fromMarkdown(markdownCode, {\n    extensions: [\n      mdxjs(),\n      gfm(),\n      frontmatter(['yaml', 'toml']),\n    ],\n    mdastExtensions: [\n      mdxFromMarkdown(),\n      gfmFromMarkdown(),\n      frontmatterFromMarkdown(['yaml', 'toml']),\n    ],\n  });\n\n  const tocAST = toc(ast);\n\n  const ctx: StateContext = {\n    source: fileName,\n    options,\n    imports: [],\n    frontmatter: undefined,\n    slugger: new GithubSlugger(),\n  };\n  const render = compileNode(ctx, ast);\n\n  const compiled = new SourceNode(null, null, fileName);\n\n  compiled.add(ctx.imports);\n  if (ctx.frontmatter) {\n    compiled.add('export const frontmatter = ');\n    compiled.add(ctx.frontmatter);\n    compiled.add(';\\n');\n  }\n  compiled.add(`import { useMDX as ${USE_MDX_VAR} } from '${options.mdxImportSource || 'solid-marked'}';\\n\\n`);\n  if (tocAST.map) {\n    const renderedTOC = compileNode(ctx, tocAST.map);\n    compiled.add('export function TableOfContents(props) {\\n');\n    compiled.add(`  const ${CTX_VAR} = ${USE_MDX_VAR}();\\n`);\n    compiled.add('  return (\\n');\n    compiled.add(renderedTOC);\n    compiled.add('\\n  );\\n');\n    compiled.add('}\\n');\n  }\n  compiled.add('export default function Component(props) {\\n');\n  compiled.add(`  const ${CTX_VAR} = ${USE_MDX_VAR}();\\n`);\n  compiled.add('  return (\\n');\n  compiled.add(render);\n  compiled.add('\\n  );\\n');\n  compiled.add('}\\n');\n\n  compiled.setSourceContent(fileName, markdownCode);\n\n  const compiledResult = compiled.toStringWithSourceMap();\n\n  return {\n    code: compiledResult.code,\n    map: compiledResult.map.toJSON(),\n  };\n}\n", "/* eslint-disable @typescript-eslint/no-use-before-define */\nimport type * as mdast from 'mdast';\nimport * as mdastString from 'mdast-util-to-string';\nimport { SourceNode } from 'source-map';\nimport type * as mdastMDX from 'mdast-util-mdx';\nimport * as seroval from 'seroval';\nimport * as yaml from 'yaml';\nimport * as toml from 'toml';\nimport type { StateContext } from './types';\nimport { serializeString } from './string';\n\ninterface TOML extends mdast.Literal {\n  type: 'toml';\n}\n\ndeclare module 'mdast' {\n  // Allow using TOML nodes defined by `mdast-util-frontmatter`.\n  interface FrontmatterContentMap {\n    toml: TOML;\n  }\n  interface RootContentMap {\n    toml: TOML;\n  }\n}\n\nfunction createSourceNode(ctx: StateContext, base: mdast.Nodes): SourceNode {\n  const col = base.position?.start.column;\n  return new SourceNode(\n    base.position?.start.line ?? null,\n    col != null ? col - 1 : null,\n    ctx.source,\n  );\n}\n\nfunction addStringAttribute(result: SourceNode, name: string, value: string): void {\n  result.add(` ${name}={${serializeString(value)}}`);\n}\nfunction addJSAttribute(result: SourceNode, name: string, expression: string): void {\n  result.add(` ${name}={${expression}}`);\n}\n\nfunction applyAssociation(result: SourceNode, node: mdast.Association): void {\n  addStringAttribute(result, 'identifier', node.identifier);\n  if (node.label) {\n    addStringAttribute(result, 'label', node.label);\n  }\n}\n\nfunction applyResource(result: SourceNode, node: mdast.Resource): void {\n  addStringAttribute(result, 'url', node.url);\n  if (node.title) {\n    addStringAttribute(result, 'title', node.title);\n  }\n}\n\nfunction applyAlternative(result: SourceNode, node: mdast.Alternative): void {\n  if (node.alt) {\n    addStringAttribute(result, 'alt', node.alt);\n  }\n}\n\nfunction applyReference(result: SourceNode, node: mdast.Reference): void {\n  applyAssociation(result, node);\n  addStringAttribute(result, 'referenceType', node.referenceType);\n}\n\ninterface TagOptions {\n  isClosing?: boolean;\n  isMDX?: boolean;\n}\n\nfunction createTag(ctx: StateContext, target: string, tagOpts: TagOptions = {}): string {\n  if (ctx.options.noDynamicComponents === 'only-mdx' && tagOpts.isMDX) {\n    return target;\n  }\n  if (ctx.options.noDynamicComponents === true) {\n    return target;\n  }\n  if (tagOpts.isClosing) {\n    return 'Dynamic';\n  }\n\n  return `Dynamic component={${target}}`;\n}\n\nfunction createJSXTag(\n  ctx: StateContext,\n  nodeName: string,\n): string {\n  if (ctx.options.noDynamicComponents) {\n    return nodeName;\n  }\n  // Test for dashed elements\n  if (/^[a-zA-Z0-9]+(-[a-zA-Z0-9]+)+$/.test(nodeName)) {\n    return `__ctx.components['${nodeName}']`;\n  }\n  if (/^[a-zA-Z0-9]+:[a-zA-Z0-9]+$/.test(nodeName)) {\n    return `__ctx.components['${nodeName}']`;\n  }\n  return `typeof ${nodeName} === 'undefined' ? __ctx.components.${nodeName} : ${nodeName}`;\n}\n\ntype ExcludedTags =\n  | 'mdxFlowExpression'\n  | 'mdxjsEsm'\n  | 'mdxJsxFlowElement'\n  | 'mdxJsxTextElement'\n  | 'mdxTextExpression'\n  | 'text'\n  | 'yaml'\n  | 'toml';\ntype WithTags = Exclude<mdast.Nodes['type'], ExcludedTags>\n\nexport const CTX_VAR = '_ctx$';\n\nconst MARKUP: Record<WithTags, string> = {\n  blockquote: `${CTX_VAR}.builtins.Blockquote`,\n  break: `${CTX_VAR}.builtins.Break`,\n  code: `${CTX_VAR}.builtins.Code`,\n  definition: `${CTX_VAR}.builtins.Definition`,\n  delete: `${CTX_VAR}.builtins.Delete`,\n  emphasis: `${CTX_VAR}.builtins.Emphasis`,\n  footnoteDefinition: `${CTX_VAR}.builtins.FootnoteDefinition`,\n  footnoteReference: `${CTX_VAR}.builtins.FootnoteReference`,\n  heading: `${CTX_VAR}.builtins.Heading`,\n  html: `${CTX_VAR}.builtins.HTML`,\n  image: `${CTX_VAR}.builtins.Image`,\n  imageReference: `${CTX_VAR}.builtins.ImageReference`,\n  inlineCode: `${CTX_VAR}.builtins.InlineCode`,\n  link: `${CTX_VAR}.builtins.Link`,\n  linkReference: `${CTX_VAR}.builtins.LinkReference`,\n  list: `${CTX_VAR}.builtins.List`,\n  listItem: `${CTX_VAR}.builtins.ListItem`,\n  paragraph: `${CTX_VAR}.builtins.Paragraph`,\n  root: `${CTX_VAR}.builtins.Root`,\n  strong: `${CTX_VAR}.builtins.Strong`,\n  table: `${CTX_VAR}.builtins.Table`,\n  tableCell: `${CTX_VAR}.builtins.TableCell`,\n  tableRow: `${CTX_VAR}.builtins.TableRow`,\n  thematicBreak: `${CTX_VAR}.builtins.ThematicBreak`,\n};\n\nfunction compileRoot(ctx: StateContext, node: mdast.Root): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.root;\n  result.add(`<${createTag(ctx, tag)}>`);\n  addContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileParagraph(ctx: StateContext, node: mdast.Paragraph): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.paragraph;\n  result.add(`<${createTag(ctx, tag)}>`);\n  addPhrasingContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileHeading(ctx: StateContext, node: mdast.Heading): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.heading;\n  const content = mdastString.toString(node, { includeImageAlt: false });\n  result.add(`<${createTag(ctx, tag)}`);\n  addJSAttribute(result, 'depth', node.depth.toString());\n  addStringAttribute(result, 'id', ctx.slugger.slug(content));\n  result.add('>');\n  addPhrasingContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileThematicBreak(ctx: StateContext, node: mdast.ThematicBreak): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(`<${createTag(ctx, MARKUP.thematicBreak)} />`);\n  return result;\n}\n\nfunction compileBlockquote(ctx: StateContext, node: mdast.Blockquote): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.blockquote;\n  result.add(`<${createTag(ctx, tag)}>`);\n  addBlockOrDefinitionContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileList(ctx: StateContext, node: mdast.List): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.list;\n  result.add(`<${createTag(ctx, tag)}`);\n  if (node.ordered != null) {\n    addJSAttribute(result, 'ordered', node.ordered.toString());\n  }\n  if (node.spread != null) {\n    addJSAttribute(result, 'spread', node.spread.toString());\n  }\n  if (node.start != null) {\n    addJSAttribute(result, 'start', node.start.toString());\n  }\n  result.add('>');\n  for (let i = 0, len = node.children.length; i < len; i += 1) {\n    result.add(compileListItem(ctx, node.children[i]));\n  }\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileListItem(ctx: StateContext, node: mdast.ListItem): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.listItem;\n  result.add(`<${createTag(ctx, tag)}`);\n  if (node.spread != null) {\n    addJSAttribute(result, 'spread', node.spread.toString());\n  }\n  if (node.checked != null) {\n    addJSAttribute(result, 'checked', node.checked.toString());\n  }\n  result.add('>');\n  addBlockOrDefinitionContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileHTML(ctx: StateContext, node: mdast.Html): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.html;\n  result.add(`<${createTag(ctx, tag)}>`);\n  result.add(`{${serializeString(node.value)}}`);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileCode(ctx: StateContext, node: mdast.Code): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.code;\n  result.add(`<${createTag(ctx, tag)}`);\n  if (node.lang) {\n    addStringAttribute(result, 'lang', node.lang);\n  }\n  if (node.meta) {\n    addStringAttribute(result, 'meta', node.meta);\n  }\n  result.add('>');\n  result.add(`{${serializeString(node.value)}}`);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileDefinition(ctx: StateContext, node: mdast.Definition): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(`<${createTag(ctx, MARKUP.definition)}`);\n  applyResource(result, node);\n  applyAssociation(result, node);\n  result.add(' />');\n  return result;\n}\n\nfunction compileText(ctx: StateContext, node: mdast.Text): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(node.value);\n  return result;\n}\n\nfunction compileEmphasis(ctx: StateContext, node: mdast.Emphasis): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.emphasis;\n  result.add(`<${createTag(ctx, tag)}>`);\n  addPhrasingContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileStrong(ctx: StateContext, node: mdast.Strong): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.strong;\n  result.add(`<${createTag(ctx, tag)}>`);\n  addPhrasingContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileInlineCode(ctx: StateContext, node: mdast.InlineCode): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.inlineCode;\n  result.add(`<${createTag(ctx, tag)}>`);\n  result.add(`{${serializeString(node.value)}}`);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileBreak(ctx: StateContext, node: mdast.Break): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(`<${createTag(ctx, MARKUP.break)} />`);\n  return result;\n}\n\nfunction compileLink(ctx: StateContext, node: mdast.Link): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.link;\n  result.add(`<${createTag(ctx, tag)}`);\n  applyResource(result, node);\n  result.add('>');\n  addPhrasingContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileImage(ctx: StateContext, node: mdast.Image): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(`<${createTag(ctx, MARKUP.image)}`);\n  applyResource(result, node);\n  applyAlternative(result, node);\n  result.add(' />');\n  return result;\n}\n\nfunction compileLinkReference(ctx: StateContext, node: mdast.LinkReference): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.linkReference;\n  result.add(`<${createTag(ctx, tag)}`);\n  applyReference(result, node);\n  result.add('>');\n  addPhrasingContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileImageReference(ctx: StateContext, node: mdast.ImageReference): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(`<${createTag(ctx, MARKUP.imageReference)}`);\n  applyReference(result, node);\n  applyAlternative(result, node);\n  result.add(' />');\n  return result;\n}\n\nfunction compileFootnoteDefinition(ctx: StateContext, node: mdast.FootnoteDefinition): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.footnoteDefinition;\n  result.add(`<${createTag(ctx, tag)}`);\n  applyAssociation(result, node);\n  result.add('>');\n  addBlockOrDefinitionContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileFootnoteReference(ctx: StateContext, node: mdast.FootnoteReference): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(`<${createTag(ctx, MARKUP.footnoteReference)}`);\n  applyAssociation(result, node);\n  result.add(' />');\n  return result;\n}\n\nfunction compileTable(ctx: StateContext, node: mdast.Table): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.table;\n  result.add(`<${createTag(ctx, tag)}`);\n  if (node.align != null) {\n    addJSAttribute(result, 'align', JSON.stringify(node.align));\n  }\n  result.add('>');\n  for (let i = 0, len = node.children.length; i < len; i += 1) {\n    result.add(compileTableRow(ctx, node.children[i], i === 0));\n  }\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileTableRow(ctx: StateContext, node: mdast.TableRow, isHead: boolean): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.tableRow;\n  result.add(`<${createTag(ctx, tag)}`);\n  if (isHead) {\n    addJSAttribute(result, 'isHead', 'true');\n  }\n  result.add('>');\n  for (let i = 0, len = node.children.length; i < len; i += 1) {\n    result.add(compileTableCell(ctx, node.children[i]));\n  }\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileTableCell(ctx: StateContext, node: mdast.TableCell): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.tableCell;\n  result.add(`<${createTag(ctx, tag)}>`);\n  addPhrasingContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileDelete(ctx: StateContext, node: mdast.Delete): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.delete;\n  result.add(`<${createTag(ctx, tag)}>`);\n  addPhrasingContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileMDXExpression(\n  ctx: StateContext,\n  node: mdastMDX.MdxTextExpression | mdastMDX.MdxFlowExpression,\n): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(`{${node.value}}`);\n  return result;\n}\n\nfunction compileMDXElement(\n  ctx: StateContext,\n  node: mdastMDX.MdxJsxTextElement | mdastMDX.MdxJsxFlowElement,\n): SourceNode {\n  const result = createSourceNode(ctx, node);\n  if (node.name) {\n    const name = createJSXTag(ctx, node.name);\n    result.add(`<${createTag(ctx, name, { isMDX: true })}`);\n    for (let i = 0, len = node.attributes.length; i < len; i += 1) {\n      const attribute = node.attributes[i];\n      const attributeNode = new SourceNode(\n        attribute.position?.start.line ?? null,\n        attribute.position?.start.column ?? null,\n        ctx.source,\n      );\n      if (attribute.type === 'mdxJsxAttribute') {\n        attributeNode.add(` ${attribute.name}`);\n        if (attribute.value) {\n          if (typeof attribute.value === 'string') {\n            attributeNode.add(`={${serializeString(attribute.value)}}`);\n          } else {\n            const attributeValueNode = new SourceNode(\n              attribute.value.position?.start.line ?? null,\n              attribute.value.position?.start.column ?? null,\n              ctx.source,\n            );\n            attributeValueNode.add(attribute.value.value);\n            attributeNode.add(['={', attributeValueNode, '}']);\n          }\n        }\n      } else {\n        attributeNode.add(` {...${attribute.value}}`);\n      }\n      result.add(attributeNode);\n    }\n    result.add('>');\n    addContent(ctx, result, node.children);\n    result.add(`</${createTag(ctx, name, { isClosing: true, isMDX: true })}>`);\n  } else {\n    result.add('<>');\n    addContent(ctx, result, node.children);\n    result.add('</>');\n  }\n  return result;\n}\n\nfunction compileMDXESM(ctx: StateContext, node: mdastMDX.MdxjsEsm): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(`${node.value}\\n`);\n  ctx.imports.push(result);\n  return new SourceNode();\n}\n\nfunction compileYAML(ctx: StateContext, node: mdast.Yaml): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(seroval.serialize(\n    yaml.parse(node.value),\n  ));\n  ctx.frontmatter = result;\n  return new SourceNode();\n}\n\nfunction compileTOML(ctx: StateContext, node: TOML): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(seroval.serialize(\n    toml.parse(node.value),\n  ));\n  ctx.frontmatter = result;\n  return new SourceNode();\n}\n\nfunction compileBlockOrDefinitionContent(\n  ctx: StateContext,\n  node: mdast.BlockContent | mdast.DefinitionContent,\n): SourceNode {\n  switch (node.type) {\n    case 'blockquote':\n      return compileBlockquote(ctx, node);\n    case 'code':\n      return compileCode(ctx, node);\n    case 'heading':\n      return compileHeading(ctx, node);\n    case 'html':\n      return compileHTML(ctx, node);\n    case 'list':\n      return compileList(ctx, node);\n    case 'mdxFlowExpression':\n      return compileMDXExpression(ctx, node);\n    case 'mdxJsxFlowElement':\n      return compileMDXElement(ctx, node);\n    case 'paragraph':\n      return compileParagraph(ctx, node);\n    case 'table':\n      return compileTable(ctx, node);\n    case 'thematicBreak':\n      return compileThematicBreak(ctx, node);\n    case 'definition':\n      return compileDefinition(ctx, node);\n    case 'footnoteDefinition':\n      return compileFootnoteDefinition(ctx, node);\n    default:\n      throw new Error('invariant');\n  }\n}\n\nfunction compilePhrasingContent(\n  ctx: StateContext,\n  node: mdast.PhrasingContent,\n): SourceNode {\n  switch (node.type) {\n    case 'break':\n      return compileBreak(ctx, node);\n    case 'delete':\n      return compileDelete(ctx, node);\n    case 'emphasis':\n      return compileEmphasis(ctx, node);\n    case 'footnoteReference':\n      return compileFootnoteReference(ctx, node);\n    case 'html':\n      return compileHTML(ctx, node);\n    case 'image':\n      return compileImage(ctx, node);\n    case 'imageReference':\n      return compileImageReference(ctx, node);\n    case 'inlineCode':\n      return compileInlineCode(ctx, node);\n    case 'mdxJsxTextElement':\n      return compileMDXElement(ctx, node);\n    case 'mdxTextExpression':\n      return compileMDXExpression(ctx, node);\n    case 'strong':\n      return compileStrong(ctx, node);\n    case 'text':\n      return compileText(ctx, node);\n    case 'link':\n      return compileLink(ctx, node);\n    case 'linkReference':\n      return compileLinkReference(ctx, node);\n    default:\n      throw new Error('invariant');\n  }\n}\n\nfunction addPhrasingContent(\n  ctx: StateContext,\n  source: SourceNode,\n  nodes: mdast.PhrasingContent[],\n): void {\n  for (let i = 0, len = nodes.length; i < len; i += 1) {\n    source.add(compilePhrasingContent(ctx, nodes[i]));\n  }\n}\n\nfunction addBlockOrDefinitionContent(\n  ctx: StateContext,\n  source: SourceNode,\n  nodes: (mdast.BlockContent | mdast.DefinitionContent)[],\n): void {\n  for (let i = 0, len = nodes.length; i < len; i += 1) {\n    source.add(compileBlockOrDefinitionContent(ctx, nodes[i]));\n  }\n}\n\nexport function compileNode(\n  ctx: StateContext,\n  node: mdast.Nodes,\n): SourceNode {\n  switch (node.type) {\n    case 'root':\n      return compileRoot(ctx, node);\n    case 'paragraph':\n      return compileParagraph(ctx, node);\n    case 'heading':\n      return compileHeading(ctx, node);\n    case 'thematicBreak':\n      return compileThematicBreak(ctx, node);\n    case 'blockquote':\n      return compileBlockquote(ctx, node);\n    case 'list':\n      return compileList(ctx, node);\n    case 'listItem':\n      return compileListItem(ctx, node);\n    case 'code':\n      return compileCode(ctx, node);\n    case 'definition':\n      return compileDefinition(ctx, node);\n    case 'text':\n      return compileText(ctx, node);\n    case 'emphasis':\n      return compileEmphasis(ctx, node);\n    case 'strong':\n      return compileStrong(ctx, node);\n    case 'inlineCode':\n      return compileInlineCode(ctx, node);\n    case 'break':\n      return compileBreak(ctx, node);\n    case 'link':\n      return compileLink(ctx, node);\n    case 'image':\n      return compileImage(ctx, node);\n    case 'linkReference':\n      return compileLinkReference(ctx, node);\n    case 'imageReference':\n      return compileImageReference(ctx, node);\n    case 'footnoteDefinition':\n      return compileFootnoteDefinition(ctx, node);\n    case 'footnoteReference':\n      return compileFootnoteReference(ctx, node);\n    case 'table':\n      return compileTable(ctx, node);\n    case 'tableCell':\n      return compileTableCell(ctx, node);\n    case 'tableRow':\n      return compileTableRow(ctx, node, false);\n    case 'delete':\n      return compileDelete(ctx, node);\n    case 'mdxTextExpression':\n    case 'mdxFlowExpression':\n      return compileMDXExpression(ctx, node);\n    case 'mdxJsxTextElement':\n    case 'mdxJsxFlowElement':\n      return compileMDXElement(ctx, node);\n    case 'mdxjsEsm':\n      return compileMDXESM(ctx, node);\n    case 'yaml':\n      return compileYAML(ctx, node);\n    case 'toml':\n      return compileTOML(ctx, node);\n    default:\n      throw new Error('Invalid node type');\n  }\n}\n\nfunction addContent(\n  ctx: StateContext,\n  source: SourceNode,\n  nodes: mdast.RootContent[],\n): void {\n  for (let i = 0, len = nodes.length; i < len; i += 1) {\n    source.add(compileNode(ctx, nodes[i]));\n  }\n}\n", "export function serializeChar(str: string): string | undefined {\n  switch (str) {\n    case '\"': return '\\\\\"';\n    case '\\\\': return '\\\\\\\\';\n    case '\\n': return '\\\\n';\n    case '\\r': return '\\\\r';\n    case '\\b': return '\\\\b';\n    case '\\t': return '\\\\t';\n    case '\\f': return '\\\\f';\n    case '<': return '\\\\x3C';\n    case '\\u2028': return '\\\\u2028';\n    case '\\u2029': return '\\\\u2029';\n    default: return undefined;\n  }\n}\n\n// Written by https://github.com/DylanPiercey and is distributed under the MIT license.\n// Creates a JavaScript double quoted string and escapes all characters\n// not listed as DoubleStringCharacters on\n// Also includes \"<\" to escape \"</script>\" and \"\\\" to avoid invalid escapes in the output.\n// http://www.ecma-international.org/ecma-262/5.1/#sec-7.8.4\nexport function serializeString(str: string): string {\n  let result = '';\n  let lastPos = 0;\n  let replacement: string | undefined;\n  for (let i = 0, len = str.length; i < len; i += 1) {\n    replacement = serializeChar(str[i]);\n    if (replacement) {\n      result += str.slice(lastPos, i) + replacement;\n      lastPos = i + 1;\n    }\n  }\n  if (lastPos === 0) {\n    result = str;\n  } else {\n    result += str.slice(lastPos);\n  }\n  return `\"${result}\"`;\n}\n"],
+  "sourcesContent": ["import type { RawSourceMap } from 'source-map';\nimport {\n  SourceNode,\n} from 'source-map';\nimport {\n  fromMarkdown,\n} from 'mdast-util-from-markdown';\nimport { mdxFromMarkdown } from 'mdast-util-mdx';\nimport { gfmFromMarkdown } from 'mdast-util-gfm';\nimport { frontmatterFromMarkdown } from 'mdast-util-frontmatter';\nimport { toc } from 'mdast-util-toc';\nimport { mdxjs } from 'micromark-extension-mdxjs';\nimport { gfm } from 'micromark-extension-gfm';\nimport { frontmatter } from 'micromark-extension-frontmatter';\nimport GithubSlugger from 'github-slugger';\nimport { CTX_VAR, compileNode } from './compiler';\nimport type { Options, StateContext } from './types';\n\nexport type { Options } from './types';\nexport * from './interfaces';\n\nconst USE_MDX_VAR = '_useMDX$';\n\nexport interface Result {\n  code: string;\n  map: RawSourceMap;\n}\n\nexport function compile(\n  fileName: string,\n  markdownCode: string,\n  options: Options = {},\n): Result {\n  const ast = fromMarkdown(markdownCode, {\n    extensions: [\n      mdxjs(),\n      gfm(),\n      frontmatter(['yaml', 'toml']),\n    ],\n    mdastExtensions: [\n      mdxFromMarkdown(),\n      gfmFromMarkdown(),\n      frontmatterFromMarkdown(['yaml', 'toml']),\n    ],\n  });\n\n  const tocAST = toc(ast, { parents: () => true });\n\n  const ctx: StateContext = {\n    source: fileName,\n    options,\n    imports: [],\n    frontmatter: undefined,\n    slugger: new GithubSlugger(),\n  };\n  const render = compileNode(ctx, ast);\n\n  const compiled = new SourceNode(null, null, fileName);\n\n  compiled.add(ctx.imports);\n  if (ctx.frontmatter) {\n    compiled.add('export const frontmatter = ');\n    compiled.add(ctx.frontmatter);\n    compiled.add(';\\n');\n  }\n  compiled.add(`import { useMDX as ${USE_MDX_VAR} } from '${options.mdxImportSource || 'solid-marked'}';\\n\\n`);\n  if (tocAST.map) {\n    const renderedTOC = compileNode(ctx, tocAST.map);\n    compiled.add('export function TableOfContents(props) {\\n');\n    compiled.add(`  const ${CTX_VAR} = ${USE_MDX_VAR}();\\n`);\n    compiled.add('  return (\\n');\n    compiled.add(renderedTOC);\n    compiled.add('\\n  );\\n');\n    compiled.add('}\\n');\n  }\n  compiled.add('export default function Component(props) {\\n');\n  compiled.add(`  const ${CTX_VAR} = ${USE_MDX_VAR}();\\n`);\n  compiled.add('  return (\\n');\n  compiled.add(render);\n  compiled.add('\\n  );\\n');\n  compiled.add('}\\n');\n\n  compiled.setSourceContent(fileName, markdownCode);\n\n  const compiledResult = compiled.toStringWithSourceMap();\n\n  return {\n    code: compiledResult.code,\n    map: compiledResult.map.toJSON(),\n  };\n}\n", "/* eslint-disable @typescript-eslint/no-use-before-define */\nimport type * as mdast from 'mdast';\nimport * as mdastString from 'mdast-util-to-string';\nimport { SourceNode } from 'source-map';\nimport type * as mdastMDX from 'mdast-util-mdx';\nimport * as seroval from 'seroval';\nimport * as yaml from 'yaml';\nimport * as toml from 'toml';\nimport type { StateContext } from './types';\nimport { serializeString } from './string';\n\ninterface TOML extends mdast.Literal {\n  type: 'toml';\n}\n\ndeclare module 'mdast' {\n  // Allow using TOML nodes defined by `mdast-util-frontmatter`.\n  interface FrontmatterContentMap {\n    toml: TOML;\n  }\n  interface RootContentMap {\n    toml: TOML;\n  }\n}\n\nfunction createSourceNode(ctx: StateContext, base: mdast.Nodes): SourceNode {\n  const col = base.position?.start.column;\n  return new SourceNode(\n    base.position?.start.line ?? null,\n    col != null ? col - 1 : null,\n    ctx.source,\n  );\n}\n\nfunction addStringAttribute(result: SourceNode, name: string, value: string): void {\n  result.add(` ${name}={${serializeString(value)}}`);\n}\nfunction addJSAttribute(result: SourceNode, name: string, expression: string): void {\n  result.add(` ${name}={${expression}}`);\n}\n\nfunction applyAssociation(result: SourceNode, node: mdast.Association): void {\n  addStringAttribute(result, 'identifier', node.identifier);\n  if (node.label) {\n    addStringAttribute(result, 'label', node.label);\n  }\n}\n\nfunction applyResource(result: SourceNode, node: mdast.Resource): void {\n  addStringAttribute(result, 'url', node.url);\n  if (node.title) {\n    addStringAttribute(result, 'title', node.title);\n  }\n}\n\nfunction applyAlternative(result: SourceNode, node: mdast.Alternative): void {\n  if (node.alt) {\n    addStringAttribute(result, 'alt', node.alt);\n  }\n}\n\nfunction applyReference(result: SourceNode, node: mdast.Reference): void {\n  applyAssociation(result, node);\n  addStringAttribute(result, 'referenceType', node.referenceType);\n}\n\ninterface TagOptions {\n  isClosing?: boolean;\n  isMDX?: boolean;\n}\n\nfunction createTag(ctx: StateContext, target: string, tagOpts: TagOptions = {}): string {\n  if (ctx.options.noDynamicComponents === 'only-mdx' && tagOpts.isMDX) {\n    return target;\n  }\n  if (ctx.options.noDynamicComponents === true) {\n    return target;\n  }\n  if (tagOpts.isClosing) {\n    return 'Dynamic';\n  }\n\n  return `Dynamic component={${target}}`;\n}\n\nfunction createJSXTag(\n  ctx: StateContext,\n  nodeName: string,\n): string {\n  if (ctx.options.noDynamicComponents) {\n    return nodeName;\n  }\n  // Test for dashed elements\n  if (/^[a-zA-Z0-9]+(-[a-zA-Z0-9]+)+$/.test(nodeName)) {\n    return `_ctx$.components['${nodeName}']`;\n  }\n  if (/^[a-zA-Z0-9]+:[a-zA-Z0-9]+$/.test(nodeName)) {\n    return `_ctx$.components['${nodeName}']`;\n  }\n  return `typeof ${nodeName} === 'undefined' ? _ctx$.components.${nodeName} : ${nodeName}`;\n}\n\ntype ExcludedTags =\n  | 'mdxFlowExpression'\n  | 'mdxjsEsm'\n  | 'mdxJsxFlowElement'\n  | 'mdxJsxTextElement'\n  | 'mdxTextExpression'\n  | 'text'\n  | 'yaml'\n  | 'toml';\ntype WithTags = Exclude<mdast.Nodes['type'], ExcludedTags>\n\nexport const CTX_VAR = '_ctx$';\n\nconst MARKUP: Record<WithTags, string> = {\n  blockquote: `${CTX_VAR}.builtins.Blockquote`,\n  break: `${CTX_VAR}.builtins.Break`,\n  code: `${CTX_VAR}.builtins.Code`,\n  definition: `${CTX_VAR}.builtins.Definition`,\n  delete: `${CTX_VAR}.builtins.Delete`,\n  emphasis: `${CTX_VAR}.builtins.Emphasis`,\n  footnoteDefinition: `${CTX_VAR}.builtins.FootnoteDefinition`,\n  footnoteReference: `${CTX_VAR}.builtins.FootnoteReference`,\n  heading: `${CTX_VAR}.builtins.Heading`,\n  html: `${CTX_VAR}.builtins.HTML`,\n  image: `${CTX_VAR}.builtins.Image`,\n  imageReference: `${CTX_VAR}.builtins.ImageReference`,\n  inlineCode: `${CTX_VAR}.builtins.InlineCode`,\n  link: `${CTX_VAR}.builtins.Link`,\n  linkReference: `${CTX_VAR}.builtins.LinkReference`,\n  list: `${CTX_VAR}.builtins.List`,\n  listItem: `${CTX_VAR}.builtins.ListItem`,\n  paragraph: `${CTX_VAR}.builtins.Paragraph`,\n  root: `${CTX_VAR}.builtins.Root`,\n  strong: `${CTX_VAR}.builtins.Strong`,\n  table: `${CTX_VAR}.builtins.Table`,\n  tableCell: `${CTX_VAR}.builtins.TableCell`,\n  tableRow: `${CTX_VAR}.builtins.TableRow`,\n  thematicBreak: `${CTX_VAR}.builtins.ThematicBreak`,\n};\n\nfunction compileRoot(ctx: StateContext, node: mdast.Root): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.root;\n  result.add(`<${createTag(ctx, tag)}>`);\n  addContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileParagraph(ctx: StateContext, node: mdast.Paragraph): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.paragraph;\n  result.add(`<${createTag(ctx, tag)}>`);\n  addPhrasingContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileHeading(ctx: StateContext, node: mdast.Heading): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.heading;\n  const content = mdastString.toString(node, { includeImageAlt: false });\n  result.add(`<${createTag(ctx, tag)}`);\n  addJSAttribute(result, 'depth', node.depth.toString());\n  addStringAttribute(result, 'id', ctx.slugger.slug(content));\n  result.add('>');\n  addPhrasingContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileThematicBreak(ctx: StateContext, node: mdast.ThematicBreak): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(`<${createTag(ctx, MARKUP.thematicBreak)} />`);\n  return result;\n}\n\nfunction compileBlockquote(ctx: StateContext, node: mdast.Blockquote): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.blockquote;\n  result.add(`<${createTag(ctx, tag)}>`);\n  addBlockOrDefinitionContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileList(ctx: StateContext, node: mdast.List): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.list;\n  result.add(`<${createTag(ctx, tag)}`);\n  if (node.ordered != null) {\n    addJSAttribute(result, 'ordered', node.ordered.toString());\n  }\n  if (node.spread != null) {\n    addJSAttribute(result, 'spread', node.spread.toString());\n  }\n  if (node.start != null) {\n    addJSAttribute(result, 'start', node.start.toString());\n  }\n  result.add('>');\n  for (let i = 0, len = node.children.length; i < len; i += 1) {\n    result.add(compileListItem(ctx, node.children[i]));\n  }\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileListItem(ctx: StateContext, node: mdast.ListItem): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.listItem;\n  result.add(`<${createTag(ctx, tag)}`);\n  if (node.spread != null) {\n    addJSAttribute(result, 'spread', node.spread.toString());\n  }\n  if (node.checked != null) {\n    addJSAttribute(result, 'checked', node.checked.toString());\n  }\n  result.add('>');\n  addBlockOrDefinitionContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileHTML(ctx: StateContext, node: mdast.Html): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.html;\n  result.add(`<${createTag(ctx, tag)}>`);\n  result.add(`{${serializeString(node.value)}}`);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileCode(ctx: StateContext, node: mdast.Code): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.code;\n  result.add(`<${createTag(ctx, tag)}`);\n  if (node.lang) {\n    addStringAttribute(result, 'lang', node.lang);\n  }\n  if (node.meta) {\n    addStringAttribute(result, 'meta', node.meta);\n  }\n  result.add('>');\n  result.add(`{${serializeString(node.value)}}`);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileDefinition(ctx: StateContext, node: mdast.Definition): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(`<${createTag(ctx, MARKUP.definition)}`);\n  applyResource(result, node);\n  applyAssociation(result, node);\n  result.add(' />');\n  return result;\n}\n\nfunction compileText(ctx: StateContext, node: mdast.Text): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(node.value);\n  return result;\n}\n\nfunction compileEmphasis(ctx: StateContext, node: mdast.Emphasis): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.emphasis;\n  result.add(`<${createTag(ctx, tag)}>`);\n  addPhrasingContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileStrong(ctx: StateContext, node: mdast.Strong): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.strong;\n  result.add(`<${createTag(ctx, tag)}>`);\n  addPhrasingContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileInlineCode(ctx: StateContext, node: mdast.InlineCode): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.inlineCode;\n  result.add(`<${createTag(ctx, tag)}>`);\n  result.add(`{${serializeString(node.value)}}`);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileBreak(ctx: StateContext, node: mdast.Break): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(`<${createTag(ctx, MARKUP.break)} />`);\n  return result;\n}\n\nfunction compileLink(ctx: StateContext, node: mdast.Link): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.link;\n  result.add(`<${createTag(ctx, tag)}`);\n  applyResource(result, node);\n  result.add('>');\n  addPhrasingContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileImage(ctx: StateContext, node: mdast.Image): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(`<${createTag(ctx, MARKUP.image)}`);\n  applyResource(result, node);\n  applyAlternative(result, node);\n  result.add(' />');\n  return result;\n}\n\nfunction compileLinkReference(ctx: StateContext, node: mdast.LinkReference): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.linkReference;\n  result.add(`<${createTag(ctx, tag)}`);\n  applyReference(result, node);\n  result.add('>');\n  addPhrasingContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileImageReference(ctx: StateContext, node: mdast.ImageReference): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(`<${createTag(ctx, MARKUP.imageReference)}`);\n  applyReference(result, node);\n  applyAlternative(result, node);\n  result.add(' />');\n  return result;\n}\n\nfunction compileFootnoteDefinition(ctx: StateContext, node: mdast.FootnoteDefinition): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.footnoteDefinition;\n  result.add(`<${createTag(ctx, tag)}`);\n  applyAssociation(result, node);\n  result.add('>');\n  addBlockOrDefinitionContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileFootnoteReference(ctx: StateContext, node: mdast.FootnoteReference): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(`<${createTag(ctx, MARKUP.footnoteReference)}`);\n  applyAssociation(result, node);\n  result.add(' />');\n  return result;\n}\n\nfunction compileTable(ctx: StateContext, node: mdast.Table): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.table;\n  result.add(`<${createTag(ctx, tag)}`);\n  if (node.align != null) {\n    addJSAttribute(result, 'align', JSON.stringify(node.align));\n  }\n  result.add('>');\n  for (let i = 0, len = node.children.length; i < len; i += 1) {\n    result.add(compileTableRow(ctx, node.children[i], i === 0));\n  }\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileTableRow(ctx: StateContext, node: mdast.TableRow, isHead: boolean): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.tableRow;\n  result.add(`<${createTag(ctx, tag)}`);\n  if (isHead) {\n    addJSAttribute(result, 'isHead', 'true');\n  }\n  result.add('>');\n  for (let i = 0, len = node.children.length; i < len; i += 1) {\n    result.add(compileTableCell(ctx, node.children[i]));\n  }\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileTableCell(ctx: StateContext, node: mdast.TableCell): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.tableCell;\n  result.add(`<${createTag(ctx, tag)}>`);\n  addPhrasingContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileDelete(ctx: StateContext, node: mdast.Delete): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.delete;\n  result.add(`<${createTag(ctx, tag)}>`);\n  addPhrasingContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileMDXExpression(\n  ctx: StateContext,\n  node: mdastMDX.MdxTextExpression | mdastMDX.MdxFlowExpression,\n): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(`{${node.value}}`);\n  return result;\n}\n\nfunction compileMDXElement(\n  ctx: StateContext,\n  node: mdastMDX.MdxJsxTextElement | mdastMDX.MdxJsxFlowElement,\n): SourceNode {\n  const result = createSourceNode(ctx, node);\n  if (node.name) {\n    const name = createJSXTag(ctx, node.name);\n    result.add(`<${createTag(ctx, name, { isMDX: true })}`);\n    for (let i = 0, len = node.attributes.length; i < len; i += 1) {\n      const attribute = node.attributes[i];\n      const attributeNode = new SourceNode(\n        attribute.position?.start.line ?? null,\n        attribute.position?.start.column ?? null,\n        ctx.source,\n      );\n      if (attribute.type === 'mdxJsxAttribute') {\n        attributeNode.add(` ${attribute.name}`);\n        if (attribute.value) {\n          if (typeof attribute.value === 'string') {\n            attributeNode.add(`={${serializeString(attribute.value)}}`);\n          } else {\n            const attributeValueNode = new SourceNode(\n              attribute.value.position?.start.line ?? null,\n              attribute.value.position?.start.column ?? null,\n              ctx.source,\n            );\n            attributeValueNode.add(attribute.value.value);\n            attributeNode.add(['={', attributeValueNode, '}']);\n          }\n        }\n      } else {\n        attributeNode.add(` {...${attribute.value}}`);\n      }\n      result.add(attributeNode);\n    }\n    result.add('>');\n    addContent(ctx, result, node.children);\n    result.add(`</${createTag(ctx, name, { isClosing: true, isMDX: true })}>`);\n  } else {\n    result.add('<>');\n    addContent(ctx, result, node.children);\n    result.add('</>');\n  }\n  return result;\n}\n\nfunction compileMDXESM(ctx: StateContext, node: mdastMDX.MdxjsEsm): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(`${node.value}\\n`);\n  ctx.imports.push(result);\n  return new SourceNode();\n}\n\nfunction compileYAML(ctx: StateContext, node: mdast.Yaml): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(seroval.serialize(\n    yaml.parse(node.value),\n  ));\n  ctx.frontmatter = result;\n  return new SourceNode();\n}\n\nfunction compileTOML(ctx: StateContext, node: TOML): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(seroval.serialize(\n    toml.parse(node.value),\n  ));\n  ctx.frontmatter = result;\n  return new SourceNode();\n}\n\nfunction compileBlockOrDefinitionContent(\n  ctx: StateContext,\n  node: mdast.BlockContent | mdast.DefinitionContent,\n): SourceNode {\n  switch (node.type) {\n    case 'blockquote':\n      return compileBlockquote(ctx, node);\n    case 'code':\n      return compileCode(ctx, node);\n    case 'heading':\n      return compileHeading(ctx, node);\n    case 'html':\n      return compileHTML(ctx, node);\n    case 'list':\n      return compileList(ctx, node);\n    case 'mdxFlowExpression':\n      return compileMDXExpression(ctx, node);\n    case 'mdxJsxFlowElement':\n      return compileMDXElement(ctx, node);\n    case 'paragraph':\n      return compileParagraph(ctx, node);\n    case 'table':\n      return compileTable(ctx, node);\n    case 'thematicBreak':\n      return compileThematicBreak(ctx, node);\n    case 'definition':\n      return compileDefinition(ctx, node);\n    case 'footnoteDefinition':\n      return compileFootnoteDefinition(ctx, node);\n    default:\n      throw new Error('invariant');\n  }\n}\n\nfunction compilePhrasingContent(\n  ctx: StateContext,\n  node: mdast.PhrasingContent,\n): SourceNode {\n  switch (node.type) {\n    case 'break':\n      return compileBreak(ctx, node);\n    case 'delete':\n      return compileDelete(ctx, node);\n    case 'emphasis':\n      return compileEmphasis(ctx, node);\n    case 'footnoteReference':\n      return compileFootnoteReference(ctx, node);\n    case 'html':\n      return compileHTML(ctx, node);\n    case 'image':\n      return compileImage(ctx, node);\n    case 'imageReference':\n      return compileImageReference(ctx, node);\n    case 'inlineCode':\n      return compileInlineCode(ctx, node);\n    case 'mdxJsxTextElement':\n      return compileMDXElement(ctx, node);\n    case 'mdxTextExpression':\n      return compileMDXExpression(ctx, node);\n    case 'strong':\n      return compileStrong(ctx, node);\n    case 'text':\n      return compileText(ctx, node);\n    case 'link':\n      return compileLink(ctx, node);\n    case 'linkReference':\n      return compileLinkReference(ctx, node);\n    default:\n      throw new Error('invariant');\n  }\n}\n\nfunction addPhrasingContent(\n  ctx: StateContext,\n  source: SourceNode,\n  nodes: mdast.PhrasingContent[],\n): void {\n  for (let i = 0, len = nodes.length; i < len; i += 1) {\n    source.add(compilePhrasingContent(ctx, nodes[i]));\n  }\n}\n\nfunction addBlockOrDefinitionContent(\n  ctx: StateContext,\n  source: SourceNode,\n  nodes: (mdast.BlockContent | mdast.DefinitionContent)[],\n): void {\n  for (let i = 0, len = nodes.length; i < len; i += 1) {\n    source.add(compileBlockOrDefinitionContent(ctx, nodes[i]));\n  }\n}\n\nexport function compileNode(\n  ctx: StateContext,\n  node: mdast.Nodes,\n): SourceNode {\n  switch (node.type) {\n    case 'root':\n      return compileRoot(ctx, node);\n    case 'paragraph':\n      return compileParagraph(ctx, node);\n    case 'heading':\n      return compileHeading(ctx, node);\n    case 'thematicBreak':\n      return compileThematicBreak(ctx, node);\n    case 'blockquote':\n      return compileBlockquote(ctx, node);\n    case 'list':\n      return compileList(ctx, node);\n    case 'listItem':\n      return compileListItem(ctx, node);\n    case 'code':\n      return compileCode(ctx, node);\n    case 'definition':\n      return compileDefinition(ctx, node);\n    case 'text':\n      return compileText(ctx, node);\n    case 'emphasis':\n      return compileEmphasis(ctx, node);\n    case 'strong':\n      return compileStrong(ctx, node);\n    case 'inlineCode':\n      return compileInlineCode(ctx, node);\n    case 'break':\n      return compileBreak(ctx, node);\n    case 'link':\n      return compileLink(ctx, node);\n    case 'image':\n      return compileImage(ctx, node);\n    case 'linkReference':\n      return compileLinkReference(ctx, node);\n    case 'imageReference':\n      return compileImageReference(ctx, node);\n    case 'footnoteDefinition':\n      return compileFootnoteDefinition(ctx, node);\n    case 'footnoteReference':\n      return compileFootnoteReference(ctx, node);\n    case 'table':\n      return compileTable(ctx, node);\n    case 'tableCell':\n      return compileTableCell(ctx, node);\n    case 'tableRow':\n      return compileTableRow(ctx, node, false);\n    case 'delete':\n      return compileDelete(ctx, node);\n    case 'mdxTextExpression':\n    case 'mdxFlowExpression':\n      return compileMDXExpression(ctx, node);\n    case 'mdxJsxTextElement':\n    case 'mdxJsxFlowElement':\n      return compileMDXElement(ctx, node);\n    case 'mdxjsEsm':\n      return compileMDXESM(ctx, node);\n    case 'yaml':\n      return compileYAML(ctx, node);\n    case 'toml':\n      return compileTOML(ctx, node);\n    default:\n      throw new Error('Invalid node type');\n  }\n}\n\nfunction addContent(\n  ctx: StateContext,\n  source: SourceNode,\n  nodes: mdast.RootContent[],\n): void {\n  for (let i = 0, len = nodes.length; i < len; i += 1) {\n    source.add(compileNode(ctx, nodes[i]));\n  }\n}\n", "export function serializeChar(str: string): string | undefined {\n  switch (str) {\n    case '\"': return '\\\\\"';\n    case '\\\\': return '\\\\\\\\';\n    case '\\n': return '\\\\n';\n    case '\\r': return '\\\\r';\n    case '\\b': return '\\\\b';\n    case '\\t': return '\\\\t';\n    case '\\f': return '\\\\f';\n    case '<': return '\\\\x3C';\n    case '\\u2028': return '\\\\u2028';\n    case '\\u2029': return '\\\\u2029';\n    default: return undefined;\n  }\n}\n\n// Written by https://github.com/DylanPiercey and is distributed under the MIT license.\n// Creates a JavaScript double quoted string and escapes all characters\n// not listed as DoubleStringCharacters on\n// Also includes \"<\" to escape \"</script>\" and \"\\\" to avoid invalid escapes in the output.\n// http://www.ecma-international.org/ecma-262/5.1/#sec-7.8.4\nexport function serializeString(str: string): string {\n  let result = '';\n  let lastPos = 0;\n  let replacement: string | undefined;\n  for (let i = 0, len = str.length; i < len; i += 1) {\n    replacement = serializeChar(str[i]);\n    if (replacement) {\n      result += str.slice(lastPos, i) + replacement;\n      lastPos = i + 1;\n    }\n  }\n  if (lastPos === 0) {\n    result = str;\n  } else {\n    result += str.slice(lastPos);\n  }\n  return `\"${result}\"`;\n}\n"],
   "mappings": "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",
   "names": ["import_source_map", "GithubSlugger"]
 }
diff --git a/dist/cjs/production/compiler.cjs b/dist/cjs/production/compiler.cjs
index d473a94dfe14736373c388780df37f6b160a519f..e47478fc41ed1296329ea85be8da6cbf5c7ef23b 100644
--- a/dist/cjs/production/compiler.cjs
+++ b/dist/cjs/production/compiler.cjs
@@ -1,6 +1,6 @@
 "use strict";var Re=Object.create;var N=Object.defineProperty;var Te=Object.getOwnPropertyDescriptor;var Me=Object.getOwnPropertyNames;var ye=Object.getPrototypeOf,De=Object.prototype.hasOwnProperty;var we=(e,t)=>{for(var r in t)N(e,r,{get:t[r],enumerable:!0})},B=(e,t,r,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of Me(t))!De.call(e,i)&&i!==r&&N(e,i,{get:()=>t[i],enumerable:!(n=Te(t,i))||n.enumerable});return e};var b=(e,t,r)=>(r=e!=null?Re(ye(e)):{},B(t||!e||!e.__esModule?N(r,"default",{value:e,enumerable:!0}):r,e)),ve=e=>B(N({},"__esModule",{value:!0}),e);var _e={};we(_e,{compile:()=>Je});module.exports=ve(_e);var me=require("source-map"),fe=require("mdast-util-from-markdown"),pe=require("mdast-util-mdx"),ge=require("mdast-util-gfm"),Se=require("mdast-util-frontmatter"),Ce=require("mdast-util-toc"),$e=require("micromark-extension-mdxjs"),he=require("micromark-extension-gfm"),be=require("micromark-extension-frontmatter"),ke=b(require("github-slugger"),1);var O=b(require("mdast-util-to-string"),1),g=require("source-map"),D=b(require("seroval"),1),J=b(require("yaml"),1),_=b(require("toml"),1);function Ee(e){switch(e){case'"':return'\\"';case"\\":return"\\\\";case`
-`:return"\\n";case"\r":return"\\r";case"\b":return"\\b";case"	":return"\\t";case"\f":return"\\f";case"<":return"\\x3C";case"\u2028":return"\\u2028";case"\u2029":return"\\u2029";default:return}}function C(e){let t="",r=0,n;for(let i=0,d=e.length;i<d;i+=1)n=Ee(e[i]),n&&(t+=e.slice(r,i)+n,r=i+1);return r===0?t=e:t+=e.slice(r),`"${t}"`}function a(e,t){var n,i,d;let r=(n=t.position)==null?void 0:n.start.column;return new g.SourceNode((d=(i=t.position)==null?void 0:i.start.line)!=null?d:null,r!=null?r-1:null,e.source)}function m(e,t,r){e.add(` ${t}={${C(r)}}`)}function f(e,t,r){e.add(` ${t}={${r}}`)}function R(e,t){m(e,"identifier",t.identifier),t.label&&m(e,"label",t.label)}function w(e,t){m(e,"url",t.url),t.title&&m(e,"title",t.title)}function z(e,t){t.alt&&m(e,"alt",t.alt)}function P(e,t){R(e,t),m(e,"referenceType",t.referenceType)}function o(e,t,r={}){return e.options.noDynamicComponents==="only-mdx"&&r.isMDX||e.options.noDynamicComponents===!0?t:r.isClosing?"Dynamic":`Dynamic component={${t}}`}function Le(e,t){return e.options.noDynamicComponents?t:/^[a-zA-Z0-9]+(-[a-zA-Z0-9]+)+$/.test(t)?`__ctx.components['${t}']`:/^[a-zA-Z0-9]+:[a-zA-Z0-9]+$/.test(t)?`__ctx.components['${t}']`:`typeof ${t} === 'undefined' ? __ctx.components.${t} : ${t}`}var s="_ctx$",l={blockquote:`${s}.builtins.Blockquote`,break:`${s}.builtins.Break`,code:`${s}.builtins.Code`,definition:`${s}.builtins.Definition`,delete:`${s}.builtins.Delete`,emphasis:`${s}.builtins.Emphasis`,footnoteDefinition:`${s}.builtins.FootnoteDefinition`,footnoteReference:`${s}.builtins.FootnoteReference`,heading:`${s}.builtins.Heading`,html:`${s}.builtins.HTML`,image:`${s}.builtins.Image`,imageReference:`${s}.builtins.ImageReference`,inlineCode:`${s}.builtins.InlineCode`,link:`${s}.builtins.Link`,linkReference:`${s}.builtins.LinkReference`,list:`${s}.builtins.List`,listItem:`${s}.builtins.ListItem`,paragraph:`${s}.builtins.Paragraph`,root:`${s}.builtins.Root`,strong:`${s}.builtins.Strong`,table:`${s}.builtins.Table`,tableCell:`${s}.builtins.TableCell`,tableRow:`${s}.builtins.TableRow`,thematicBreak:`${s}.builtins.ThematicBreak`};function Xe(e,t){let r=a(e,t),n=l.root;return r.add(`<${o(e,n)}>`),y(e,r,t.children),r.add(`</${o(e,n,{isClosing:!0})}>`),r}function q(e,t){let r=a(e,t),n=l.paragraph;return r.add(`<${o(e,n)}>`),p(e,r,t.children),r.add(`</${o(e,n,{isClosing:!0})}>`),r}function H(e,t){let r=a(e,t),n=l.heading,i=O.toString(t,{includeImageAlt:!1});return r.add(`<${o(e,n)}`),f(r,"depth",t.depth.toString()),m(r,"id",e.slugger.slug(i)),r.add(">"),p(e,r,t.children),r.add(`</${o(e,n,{isClosing:!0})}>`),r}function j(e,t){let r=a(e,t);return r.add(`<${o(e,l.thematicBreak)} />`),r}function V(e,t){let r=a(e,t),n=l.blockquote;return r.add(`<${o(e,n)}>`),L(e,r,t.children),r.add(`</${o(e,n,{isClosing:!0})}>`),r}function Z(e,t){let r=a(e,t),n=l.list;r.add(`<${o(e,n)}`),t.ordered!=null&&f(r,"ordered",t.ordered.toString()),t.spread!=null&&f(r,"spread",t.spread.toString()),t.start!=null&&f(r,"start",t.start.toString()),r.add(">");for(let i=0,d=t.children.length;i<d;i+=1)r.add(W(e,t.children[i]));return r.add(`</${o(e,n,{isClosing:!0})}>`),r}function W(e,t){let r=a(e,t),n=l.listItem;return r.add(`<${o(e,n)}`),t.spread!=null&&f(r,"spread",t.spread.toString()),t.checked!=null&&f(r,"checked",t.checked.toString()),r.add(">"),L(e,r,t.children),r.add(`</${o(e,n,{isClosing:!0})}>`),r}function U(e,t){let r=a(e,t),n=l.html;return r.add(`<${o(e,n)}>`),r.add(`{${C(t.value)}}`),r.add(`</${o(e,n,{isClosing:!0})}>`),r}function Y(e,t){let r=a(e,t),n=l.code;return r.add(`<${o(e,n)}`),t.lang&&m(r,"lang",t.lang),t.meta&&m(r,"meta",t.meta),r.add(">"),r.add(`{${C(t.value)}}`),r.add(`</${o(e,n,{isClosing:!0})}>`),r}function G(e,t){let r=a(e,t);return r.add(`<${o(e,l.definition)}`),w(r,t),R(r,t),r.add(" />"),r}function K(e,t){let r=a(e,t);return r.add(t.value),r}function x(e,t){let r=a(e,t),n=l.emphasis;return r.add(`<${o(e,n)}>`),p(e,r,t.children),r.add(`</${o(e,n,{isClosing:!0})}>`),r}function Q(e,t){let r=a(e,t),n=l.strong;return r.add(`<${o(e,n)}>`),p(e,r,t.children),r.add(`</${o(e,n,{isClosing:!0})}>`),r}function ee(e,t){let r=a(e,t),n=l.inlineCode;return r.add(`<${o(e,n)}>`),r.add(`{${C(t.value)}}`),r.add(`</${o(e,n,{isClosing:!0})}>`),r}function te(e,t){let r=a(e,t);return r.add(`<${o(e,l.break)} />`),r}function re(e,t){let r=a(e,t),n=l.link;return r.add(`<${o(e,n)}`),w(r,t),r.add(">"),p(e,r,t.children),r.add(`</${o(e,n,{isClosing:!0})}>`),r}function ne(e,t){let r=a(e,t);return r.add(`<${o(e,l.image)}`),w(r,t),z(r,t),r.add(" />"),r}function oe(e,t){let r=a(e,t),n=l.linkReference;return r.add(`<${o(e,n)}`),P(r,t),r.add(">"),p(e,r,t.children),r.add(`</${o(e,n,{isClosing:!0})}>`),r}function ie(e,t){let r=a(e,t);return r.add(`<${o(e,l.imageReference)}`),P(r,t),z(r,t),r.add(" />"),r}function ae(e,t){let r=a(e,t),n=l.footnoteDefinition;return r.add(`<${o(e,n)}`),R(r,t),r.add(">"),L(e,r,t.children),r.add(`</${o(e,n,{isClosing:!0})}>`),r}function se(e,t){let r=a(e,t);return r.add(`<${o(e,l.footnoteReference)}`),R(r,t),r.add(" />"),r}function le(e,t){let r=a(e,t),n=l.table;r.add(`<${o(e,n)}`),t.align!=null&&f(r,"align",JSON.stringify(t.align)),r.add(">");for(let i=0,d=t.children.length;i<d;i+=1)r.add(ue(e,t.children[i],i===0));return r.add(`</${o(e,n,{isClosing:!0})}>`),r}function ue(e,t,r){let n=a(e,t),i=l.tableRow;n.add(`<${o(e,i)}`),r&&f(n,"isHead","true"),n.add(">");for(let d=0,S=t.children.length;d<S;d+=1)n.add(de(e,t.children[d]));return n.add(`</${o(e,i,{isClosing:!0})}>`),n}function de(e,t){let r=a(e,t),n=l.tableCell;return r.add(`<${o(e,n)}>`),p(e,r,t.children),r.add(`</${o(e,n,{isClosing:!0})}>`),r}function ce(e,t){let r=a(e,t),n=l.delete;return r.add(`<${o(e,n)}>`),p(e,r,t.children),r.add(`</${o(e,n,{isClosing:!0})}>`),r}function v(e,t){let r=a(e,t);return r.add(`{${t.value}}`),r}function E(e,t){var n,i,d,S,u,$,k,A;let r=a(e,t);if(t.name){let F=Le(e,t.name);r.add(`<${o(e,F,{isMDX:!0})}`);for(let M=0,Ne=t.attributes.length;M<Ne;M+=1){let c=t.attributes[M],h=new g.SourceNode((i=(n=c.position)==null?void 0:n.start.line)!=null?i:null,(S=(d=c.position)==null?void 0:d.start.column)!=null?S:null,e.source);if(c.type==="mdxJsxAttribute"){if(h.add(` ${c.name}`),c.value)if(typeof c.value=="string")h.add(`={${C(c.value)}}`);else{let I=new g.SourceNode(($=(u=c.value.position)==null?void 0:u.start.line)!=null?$:null,(A=(k=c.value.position)==null?void 0:k.start.column)!=null?A:null,e.source);I.add(c.value.value),h.add(["={",I,"}"])}}else h.add(` {...${c.value}}`);r.add(h)}r.add(">"),y(e,r,t.children),r.add(`</${o(e,F,{isClosing:!0,isMDX:!0})}>`)}else r.add("<>"),y(e,r,t.children),r.add("</>");return r}function Ae(e,t){let r=a(e,t);return r.add(`${t.value}
-`),e.imports.push(r),new g.SourceNode}function Fe(e,t){let r=a(e,t);return r.add(D.serialize(J.parse(t.value))),e.frontmatter=r,new g.SourceNode}function Ie(e,t){let r=a(e,t);return r.add(D.serialize(_.parse(t.value))),e.frontmatter=r,new g.SourceNode}function Be(e,t){switch(t.type){case"blockquote":return V(e,t);case"code":return Y(e,t);case"heading":return H(e,t);case"html":return U(e,t);case"list":return Z(e,t);case"mdxFlowExpression":return v(e,t);case"mdxJsxFlowElement":return E(e,t);case"paragraph":return q(e,t);case"table":return le(e,t);case"thematicBreak":return j(e,t);case"definition":return G(e,t);case"footnoteDefinition":return ae(e,t);default:throw new Error("invariant")}}function Oe(e,t){switch(t.type){case"break":return te(e,t);case"delete":return ce(e,t);case"emphasis":return x(e,t);case"footnoteReference":return se(e,t);case"html":return U(e,t);case"image":return ne(e,t);case"imageReference":return ie(e,t);case"inlineCode":return ee(e,t);case"mdxJsxTextElement":return E(e,t);case"mdxTextExpression":return v(e,t);case"strong":return Q(e,t);case"text":return K(e,t);case"link":return re(e,t);case"linkReference":return oe(e,t);default:throw new Error("invariant")}}function p(e,t,r){for(let n=0,i=r.length;n<i;n+=1)t.add(Oe(e,r[n]))}function L(e,t,r){for(let n=0,i=r.length;n<i;n+=1)t.add(Be(e,r[n]))}function T(e,t){switch(t.type){case"root":return Xe(e,t);case"paragraph":return q(e,t);case"heading":return H(e,t);case"thematicBreak":return j(e,t);case"blockquote":return V(e,t);case"list":return Z(e,t);case"listItem":return W(e,t);case"code":return Y(e,t);case"definition":return G(e,t);case"text":return K(e,t);case"emphasis":return x(e,t);case"strong":return Q(e,t);case"inlineCode":return ee(e,t);case"break":return te(e,t);case"link":return re(e,t);case"image":return ne(e,t);case"linkReference":return oe(e,t);case"imageReference":return ie(e,t);case"footnoteDefinition":return ae(e,t);case"footnoteReference":return se(e,t);case"table":return le(e,t);case"tableCell":return de(e,t);case"tableRow":return ue(e,t,!1);case"delete":return ce(e,t);case"mdxTextExpression":case"mdxFlowExpression":return v(e,t);case"mdxJsxTextElement":case"mdxJsxFlowElement":return E(e,t);case"mdxjsEsm":return Ae(e,t);case"yaml":return Fe(e,t);case"toml":return Ie(e,t);default:throw new Error("Invalid node type")}}function y(e,t,r){for(let n=0,i=r.length;n<i;n+=1)t.add(T(e,r[n]))}var X="_useMDX$";function Je(e,t,r={}){let n=(0,fe.fromMarkdown)(t,{extensions:[(0,$e.mdxjs)(),(0,he.gfm)(),(0,be.frontmatter)(["yaml","toml"])],mdastExtensions:[(0,pe.mdxFromMarkdown)(),(0,ge.gfmFromMarkdown)(),(0,Se.frontmatterFromMarkdown)(["yaml","toml"])]}),i=(0,Ce.toc)(n),d={source:e,options:r,imports:[],frontmatter:void 0,slugger:new ke.default},S=T(d,n),u=new me.SourceNode(null,null,e);if(u.add(d.imports),d.frontmatter&&(u.add("export const frontmatter = "),u.add(d.frontmatter),u.add(`;
+`:return"\\n";case"\r":return"\\r";case"\b":return"\\b";case"	":return"\\t";case"\f":return"\\f";case"<":return"\\x3C";case"\u2028":return"\\u2028";case"\u2029":return"\\u2029";default:return}}function C(e){let t="",r=0,n;for(let i=0,d=e.length;i<d;i+=1)n=Ee(e[i]),n&&(t+=e.slice(r,i)+n,r=i+1);return r===0?t=e:t+=e.slice(r),`"${t}"`}function a(e,t){var n,i,d;let r=(n=t.position)==null?void 0:n.start.column;return new g.SourceNode((d=(i=t.position)==null?void 0:i.start.line)!=null?d:null,r!=null?r-1:null,e.source)}function m(e,t,r){e.add(` ${t}={${C(r)}}`)}function f(e,t,r){e.add(` ${t}={${r}}`)}function R(e,t){m(e,"identifier",t.identifier),t.label&&m(e,"label",t.label)}function w(e,t){m(e,"url",t.url),t.title&&m(e,"title",t.title)}function z(e,t){t.alt&&m(e,"alt",t.alt)}function P(e,t){R(e,t),m(e,"referenceType",t.referenceType)}function o(e,t,r={}){return e.options.noDynamicComponents==="only-mdx"&&r.isMDX||e.options.noDynamicComponents===!0?t:r.isClosing?"Dynamic":`Dynamic component={${t}}`}function Le(e,t){return e.options.noDynamicComponents?t:/^[a-zA-Z0-9]+(-[a-zA-Z0-9]+)+$/.test(t)?`_ctx$.components['${t}']`:/^[a-zA-Z0-9]+:[a-zA-Z0-9]+$/.test(t)?`_ctx$.components['${t}']`:`typeof ${t} === 'undefined' ? _ctx$.components.${t} : ${t}`}var s="_ctx$",l={blockquote:`${s}.builtins.Blockquote`,break:`${s}.builtins.Break`,code:`${s}.builtins.Code`,definition:`${s}.builtins.Definition`,delete:`${s}.builtins.Delete`,emphasis:`${s}.builtins.Emphasis`,footnoteDefinition:`${s}.builtins.FootnoteDefinition`,footnoteReference:`${s}.builtins.FootnoteReference`,heading:`${s}.builtins.Heading`,html:`${s}.builtins.HTML`,image:`${s}.builtins.Image`,imageReference:`${s}.builtins.ImageReference`,inlineCode:`${s}.builtins.InlineCode`,link:`${s}.builtins.Link`,linkReference:`${s}.builtins.LinkReference`,list:`${s}.builtins.List`,listItem:`${s}.builtins.ListItem`,paragraph:`${s}.builtins.Paragraph`,root:`${s}.builtins.Root`,strong:`${s}.builtins.Strong`,table:`${s}.builtins.Table`,tableCell:`${s}.builtins.TableCell`,tableRow:`${s}.builtins.TableRow`,thematicBreak:`${s}.builtins.ThematicBreak`};function Xe(e,t){let r=a(e,t),n=l.root;return r.add(`<${o(e,n)}>`),y(e,r,t.children),r.add(`</${o(e,n,{isClosing:!0})}>`),r}function q(e,t){let r=a(e,t),n=l.paragraph;return r.add(`<${o(e,n)}>`),p(e,r,t.children),r.add(`</${o(e,n,{isClosing:!0})}>`),r}function H(e,t){let r=a(e,t),n=l.heading,i=O.toString(t,{includeImageAlt:!1});return r.add(`<${o(e,n)}`),f(r,"depth",t.depth.toString()),m(r,"id",e.slugger.slug(i)),r.add(">"),p(e,r,t.children),r.add(`</${o(e,n,{isClosing:!0})}>`),r}function j(e,t){let r=a(e,t);return r.add(`<${o(e,l.thematicBreak)} />`),r}function V(e,t){let r=a(e,t),n=l.blockquote;return r.add(`<${o(e,n)}>`),L(e,r,t.children),r.add(`</${o(e,n,{isClosing:!0})}>`),r}function Z(e,t){let r=a(e,t),n=l.list;r.add(`<${o(e,n)}`),t.ordered!=null&&f(r,"ordered",t.ordered.toString()),t.spread!=null&&f(r,"spread",t.spread.toString()),t.start!=null&&f(r,"start",t.start.toString()),r.add(">");for(let i=0,d=t.children.length;i<d;i+=1)r.add(W(e,t.children[i]));return r.add(`</${o(e,n,{isClosing:!0})}>`),r}function W(e,t){let r=a(e,t),n=l.listItem;return r.add(`<${o(e,n)}`),t.spread!=null&&f(r,"spread",t.spread.toString()),t.checked!=null&&f(r,"checked",t.checked.toString()),r.add(">"),L(e,r,t.children),r.add(`</${o(e,n,{isClosing:!0})}>`),r}function U(e,t){let r=a(e,t),n=l.html;return r.add(`<${o(e,n)}>`),r.add(`{${C(t.value)}}`),r.add(`</${o(e,n,{isClosing:!0})}>`),r}function Y(e,t){let r=a(e,t),n=l.code;return r.add(`<${o(e,n)}`),t.lang&&m(r,"lang",t.lang),t.meta&&m(r,"meta",t.meta),r.add(">"),r.add(`{${C(t.value)}}`),r.add(`</${o(e,n,{isClosing:!0})}>`),r}function G(e,t){let r=a(e,t);return r.add(`<${o(e,l.definition)}`),w(r,t),R(r,t),r.add(" />"),r}function K(e,t){let r=a(e,t);return r.add(t.value),r}function x(e,t){let r=a(e,t),n=l.emphasis;return r.add(`<${o(e,n)}>`),p(e,r,t.children),r.add(`</${o(e,n,{isClosing:!0})}>`),r}function Q(e,t){let r=a(e,t),n=l.strong;return r.add(`<${o(e,n)}>`),p(e,r,t.children),r.add(`</${o(e,n,{isClosing:!0})}>`),r}function ee(e,t){let r=a(e,t),n=l.inlineCode;return r.add(`<${o(e,n)}>`),r.add(`{${C(t.value)}}`),r.add(`</${o(e,n,{isClosing:!0})}>`),r}function te(e,t){let r=a(e,t);return r.add(`<${o(e,l.break)} />`),r}function re(e,t){let r=a(e,t),n=l.link;return r.add(`<${o(e,n)}`),w(r,t),r.add(">"),p(e,r,t.children),r.add(`</${o(e,n,{isClosing:!0})}>`),r}function ne(e,t){let r=a(e,t);return r.add(`<${o(e,l.image)}`),w(r,t),z(r,t),r.add(" />"),r}function oe(e,t){let r=a(e,t),n=l.linkReference;return r.add(`<${o(e,n)}`),P(r,t),r.add(">"),p(e,r,t.children),r.add(`</${o(e,n,{isClosing:!0})}>`),r}function ie(e,t){let r=a(e,t);return r.add(`<${o(e,l.imageReference)}`),P(r,t),z(r,t),r.add(" />"),r}function ae(e,t){let r=a(e,t),n=l.footnoteDefinition;return r.add(`<${o(e,n)}`),R(r,t),r.add(">"),L(e,r,t.children),r.add(`</${o(e,n,{isClosing:!0})}>`),r}function se(e,t){let r=a(e,t);return r.add(`<${o(e,l.footnoteReference)}`),R(r,t),r.add(" />"),r}function le(e,t){let r=a(e,t),n=l.table;r.add(`<${o(e,n)}`),t.align!=null&&f(r,"align",JSON.stringify(t.align)),r.add(">");for(let i=0,d=t.children.length;i<d;i+=1)r.add(ue(e,t.children[i],i===0));return r.add(`</${o(e,n,{isClosing:!0})}>`),r}function ue(e,t,r){let n=a(e,t),i=l.tableRow;n.add(`<${o(e,i)}`),r&&f(n,"isHead","true"),n.add(">");for(let d=0,S=t.children.length;d<S;d+=1)n.add(de(e,t.children[d]));return n.add(`</${o(e,i,{isClosing:!0})}>`),n}function de(e,t){let r=a(e,t),n=l.tableCell;return r.add(`<${o(e,n)}>`),p(e,r,t.children),r.add(`</${o(e,n,{isClosing:!0})}>`),r}function ce(e,t){let r=a(e,t),n=l.delete;return r.add(`<${o(e,n)}>`),p(e,r,t.children),r.add(`</${o(e,n,{isClosing:!0})}>`),r}function v(e,t){let r=a(e,t);return r.add(`{${t.value}}`),r}function E(e,t){var n,i,d,S,u,$,k,A;let r=a(e,t);if(t.name){let F=Le(e,t.name);r.add(`<${o(e,F,{isMDX:!0})}`);for(let M=0,Ne=t.attributes.length;M<Ne;M+=1){let c=t.attributes[M],h=new g.SourceNode((i=(n=c.position)==null?void 0:n.start.line)!=null?i:null,(S=(d=c.position)==null?void 0:d.start.column)!=null?S:null,e.source);if(c.type==="mdxJsxAttribute"){if(h.add(` ${c.name}`),c.value)if(typeof c.value=="string")h.add(`={${C(c.value)}}`);else{let I=new g.SourceNode(($=(u=c.value.position)==null?void 0:u.start.line)!=null?$:null,(A=(k=c.value.position)==null?void 0:k.start.column)!=null?A:null,e.source);I.add(c.value.value),h.add(["={",I,"}"])}}else h.add(` {...${c.value}}`);r.add(h)}r.add(">"),y(e,r,t.children),r.add(`</${o(e,F,{isClosing:!0,isMDX:!0})}>`)}else r.add("<>"),y(e,r,t.children),r.add("</>");return r}function Ae(e,t){let r=a(e,t);return r.add(`${t.value}
+`),e.imports.push(r),new g.SourceNode}function Fe(e,t){let r=a(e,t);return r.add(D.serialize(J.parse(t.value))),e.frontmatter=r,new g.SourceNode}function Ie(e,t){let r=a(e,t);return r.add(D.serialize(_.parse(t.value))),e.frontmatter=r,new g.SourceNode}function Be(e,t){switch(t.type){case"blockquote":return V(e,t);case"code":return Y(e,t);case"heading":return H(e,t);case"html":return U(e,t);case"list":return Z(e,t);case"mdxFlowExpression":return v(e,t);case"mdxJsxFlowElement":return E(e,t);case"paragraph":return q(e,t);case"table":return le(e,t);case"thematicBreak":return j(e,t);case"definition":return G(e,t);case"footnoteDefinition":return ae(e,t);default:throw new Error("invariant")}}function Oe(e,t){switch(t.type){case"break":return te(e,t);case"delete":return ce(e,t);case"emphasis":return x(e,t);case"footnoteReference":return se(e,t);case"html":return U(e,t);case"image":return ne(e,t);case"imageReference":return ie(e,t);case"inlineCode":return ee(e,t);case"mdxJsxTextElement":return E(e,t);case"mdxTextExpression":return v(e,t);case"strong":return Q(e,t);case"text":return K(e,t);case"link":return re(e,t);case"linkReference":return oe(e,t);default:throw new Error("invariant")}}function p(e,t,r){for(let n=0,i=r.length;n<i;n+=1)t.add(Oe(e,r[n]))}function L(e,t,r){for(let n=0,i=r.length;n<i;n+=1)t.add(Be(e,r[n]))}function T(e,t){switch(t.type){case"root":return Xe(e,t);case"paragraph":return q(e,t);case"heading":return H(e,t);case"thematicBreak":return j(e,t);case"blockquote":return V(e,t);case"list":return Z(e,t);case"listItem":return W(e,t);case"code":return Y(e,t);case"definition":return G(e,t);case"text":return K(e,t);case"emphasis":return x(e,t);case"strong":return Q(e,t);case"inlineCode":return ee(e,t);case"break":return te(e,t);case"link":return re(e,t);case"image":return ne(e,t);case"linkReference":return oe(e,t);case"imageReference":return ie(e,t);case"footnoteDefinition":return ae(e,t);case"footnoteReference":return se(e,t);case"table":return le(e,t);case"tableCell":return de(e,t);case"tableRow":return ue(e,t,!1);case"delete":return ce(e,t);case"mdxTextExpression":case"mdxFlowExpression":return v(e,t);case"mdxJsxTextElement":case"mdxJsxFlowElement":return E(e,t);case"mdxjsEsm":return Ae(e,t);case"yaml":return Fe(e,t);case"toml":return Ie(e,t);default:throw new Error("Invalid node type")}}function y(e,t,r){for(let n=0,i=r.length;n<i;n+=1)t.add(T(e,r[n]))}var X="_useMDX$";function Je(e,t,r={}){let n=(0,fe.fromMarkdown)(t,{extensions:[(0,$e.mdxjs)(),(0,he.gfm)(),(0,be.frontmatter)(["yaml","toml"])],mdastExtensions:[(0,pe.mdxFromMarkdown)(),(0,ge.gfmFromMarkdown)(),(0,Se.frontmatterFromMarkdown)(["yaml","toml"])]}),i=(0,Ce.toc)(n,{parents:()=>true}),d={source:e,options:r,imports:[],frontmatter:void 0,slugger:new ke.default},S=T(d,n),u=new me.SourceNode(null,null,e);if(u.add(d.imports),d.frontmatter&&(u.add("export const frontmatter = "),u.add(d.frontmatter),u.add(`;
 `)),u.add(`import { useMDX as ${X} } from '${r.mdxImportSource||"solid-marked"}';
 
 `),i.map){let k=T(d,i.map);u.add(`export function TableOfContents(props) {
diff --git a/dist/esm/development/compiler.mjs b/dist/esm/development/compiler.mjs
index c5f534d0754352376e32ed76ec2f5a650e171513..02f7a292b4dabd651058eb4bf46cc72dc5ee9be2 100644
--- a/dist/esm/development/compiler.mjs
+++ b/dist/esm/development/compiler.mjs
@@ -121,12 +121,12 @@ function createJSXTag(ctx, nodeName) {
     return nodeName;
   }
   if (/^[a-zA-Z0-9]+(-[a-zA-Z0-9]+)+$/.test(nodeName)) {
-    return `__ctx.components['${nodeName}']`;
+    return `_ctx$.components['${nodeName}']`;
   }
   if (/^[a-zA-Z0-9]+:[a-zA-Z0-9]+$/.test(nodeName)) {
-    return `__ctx.components['${nodeName}']`;
+    return `_ctx$.components['${nodeName}']`;
   }
-  return `typeof ${nodeName} === 'undefined' ? __ctx.components.${nodeName} : ${nodeName}`;
+  return `typeof ${nodeName} === 'undefined' ? _ctx$.components.${nodeName} : ${nodeName}`;
 }
 var CTX_VAR = "_ctx$";
 var MARKUP = {
@@ -625,7 +625,7 @@ function compile(fileName, markdownCode, options = {}) {
       frontmatterFromMarkdown(["yaml", "toml"])
     ]
   });
-  const tocAST = toc(ast);
+  const tocAST = toc(ast, { parents: () => true });
   const ctx = {
     source: fileName,
     options,
diff --git a/dist/esm/development/compiler.mjs.map b/dist/esm/development/compiler.mjs.map
index d0ef6072061f469d79b1f800698b519463b07ec4..63d463090797cd8f5b5cbd35782e99317fe0c518 100644
--- a/dist/esm/development/compiler.mjs.map
+++ b/dist/esm/development/compiler.mjs.map
@@ -1,7 +1,7 @@
 {
   "version": 3,
   "sources": ["../../../compiler/index.ts", "../../../compiler/compiler.ts", "../../../compiler/string.ts"],
-  "sourcesContent": ["import type { RawSourceMap } from 'source-map';\nimport {\n  SourceNode,\n} from 'source-map';\nimport {\n  fromMarkdown,\n} from 'mdast-util-from-markdown';\nimport { mdxFromMarkdown } from 'mdast-util-mdx';\nimport { gfmFromMarkdown } from 'mdast-util-gfm';\nimport { frontmatterFromMarkdown } from 'mdast-util-frontmatter';\nimport { toc } from 'mdast-util-toc';\nimport { mdxjs } from 'micromark-extension-mdxjs';\nimport { gfm } from 'micromark-extension-gfm';\nimport { frontmatter } from 'micromark-extension-frontmatter';\nimport GithubSlugger from 'github-slugger';\nimport { CTX_VAR, compileNode } from './compiler';\nimport type { Options, StateContext } from './types';\n\nexport type { Options } from './types';\nexport * from './interfaces';\n\nconst USE_MDX_VAR = '_useMDX$';\n\nexport interface Result {\n  code: string;\n  map: RawSourceMap;\n}\n\nexport function compile(\n  fileName: string,\n  markdownCode: string,\n  options: Options = {},\n): Result {\n  const ast = fromMarkdown(markdownCode, {\n    extensions: [\n      mdxjs(),\n      gfm(),\n      frontmatter(['yaml', 'toml']),\n    ],\n    mdastExtensions: [\n      mdxFromMarkdown(),\n      gfmFromMarkdown(),\n      frontmatterFromMarkdown(['yaml', 'toml']),\n    ],\n  });\n\n  const tocAST = toc(ast);\n\n  const ctx: StateContext = {\n    source: fileName,\n    options,\n    imports: [],\n    frontmatter: undefined,\n    slugger: new GithubSlugger(),\n  };\n  const render = compileNode(ctx, ast);\n\n  const compiled = new SourceNode(null, null, fileName);\n\n  compiled.add(ctx.imports);\n  if (ctx.frontmatter) {\n    compiled.add('export const frontmatter = ');\n    compiled.add(ctx.frontmatter);\n    compiled.add(';\\n');\n  }\n  compiled.add(`import { useMDX as ${USE_MDX_VAR} } from '${options.mdxImportSource || 'solid-marked'}';\\n\\n`);\n  if (tocAST.map) {\n    const renderedTOC = compileNode(ctx, tocAST.map);\n    compiled.add('export function TableOfContents(props) {\\n');\n    compiled.add(`  const ${CTX_VAR} = ${USE_MDX_VAR}();\\n`);\n    compiled.add('  return (\\n');\n    compiled.add(renderedTOC);\n    compiled.add('\\n  );\\n');\n    compiled.add('}\\n');\n  }\n  compiled.add('export default function Component(props) {\\n');\n  compiled.add(`  const ${CTX_VAR} = ${USE_MDX_VAR}();\\n`);\n  compiled.add('  return (\\n');\n  compiled.add(render);\n  compiled.add('\\n  );\\n');\n  compiled.add('}\\n');\n\n  compiled.setSourceContent(fileName, markdownCode);\n\n  const compiledResult = compiled.toStringWithSourceMap();\n\n  return {\n    code: compiledResult.code,\n    map: compiledResult.map.toJSON(),\n  };\n}\n", "/* eslint-disable @typescript-eslint/no-use-before-define */\nimport type * as mdast from 'mdast';\nimport * as mdastString from 'mdast-util-to-string';\nimport { SourceNode } from 'source-map';\nimport type * as mdastMDX from 'mdast-util-mdx';\nimport * as seroval from 'seroval';\nimport * as yaml from 'yaml';\nimport * as toml from 'toml';\nimport type { StateContext } from './types';\nimport { serializeString } from './string';\n\ninterface TOML extends mdast.Literal {\n  type: 'toml';\n}\n\ndeclare module 'mdast' {\n  // Allow using TOML nodes defined by `mdast-util-frontmatter`.\n  interface FrontmatterContentMap {\n    toml: TOML;\n  }\n  interface RootContentMap {\n    toml: TOML;\n  }\n}\n\nfunction createSourceNode(ctx: StateContext, base: mdast.Nodes): SourceNode {\n  const col = base.position?.start.column;\n  return new SourceNode(\n    base.position?.start.line ?? null,\n    col != null ? col - 1 : null,\n    ctx.source,\n  );\n}\n\nfunction addStringAttribute(result: SourceNode, name: string, value: string): void {\n  result.add(` ${name}={${serializeString(value)}}`);\n}\nfunction addJSAttribute(result: SourceNode, name: string, expression: string): void {\n  result.add(` ${name}={${expression}}`);\n}\n\nfunction applyAssociation(result: SourceNode, node: mdast.Association): void {\n  addStringAttribute(result, 'identifier', node.identifier);\n  if (node.label) {\n    addStringAttribute(result, 'label', node.label);\n  }\n}\n\nfunction applyResource(result: SourceNode, node: mdast.Resource): void {\n  addStringAttribute(result, 'url', node.url);\n  if (node.title) {\n    addStringAttribute(result, 'title', node.title);\n  }\n}\n\nfunction applyAlternative(result: SourceNode, node: mdast.Alternative): void {\n  if (node.alt) {\n    addStringAttribute(result, 'alt', node.alt);\n  }\n}\n\nfunction applyReference(result: SourceNode, node: mdast.Reference): void {\n  applyAssociation(result, node);\n  addStringAttribute(result, 'referenceType', node.referenceType);\n}\n\ninterface TagOptions {\n  isClosing?: boolean;\n  isMDX?: boolean;\n}\n\nfunction createTag(ctx: StateContext, target: string, tagOpts: TagOptions = {}): string {\n  if (ctx.options.noDynamicComponents === 'only-mdx' && tagOpts.isMDX) {\n    return target;\n  }\n  if (ctx.options.noDynamicComponents === true) {\n    return target;\n  }\n  if (tagOpts.isClosing) {\n    return 'Dynamic';\n  }\n\n  return `Dynamic component={${target}}`;\n}\n\nfunction createJSXTag(\n  ctx: StateContext,\n  nodeName: string,\n): string {\n  if (ctx.options.noDynamicComponents) {\n    return nodeName;\n  }\n  // Test for dashed elements\n  if (/^[a-zA-Z0-9]+(-[a-zA-Z0-9]+)+$/.test(nodeName)) {\n    return `__ctx.components['${nodeName}']`;\n  }\n  if (/^[a-zA-Z0-9]+:[a-zA-Z0-9]+$/.test(nodeName)) {\n    return `__ctx.components['${nodeName}']`;\n  }\n  return `typeof ${nodeName} === 'undefined' ? __ctx.components.${nodeName} : ${nodeName}`;\n}\n\ntype ExcludedTags =\n  | 'mdxFlowExpression'\n  | 'mdxjsEsm'\n  | 'mdxJsxFlowElement'\n  | 'mdxJsxTextElement'\n  | 'mdxTextExpression'\n  | 'text'\n  | 'yaml'\n  | 'toml';\ntype WithTags = Exclude<mdast.Nodes['type'], ExcludedTags>\n\nexport const CTX_VAR = '_ctx$';\n\nconst MARKUP: Record<WithTags, string> = {\n  blockquote: `${CTX_VAR}.builtins.Blockquote`,\n  break: `${CTX_VAR}.builtins.Break`,\n  code: `${CTX_VAR}.builtins.Code`,\n  definition: `${CTX_VAR}.builtins.Definition`,\n  delete: `${CTX_VAR}.builtins.Delete`,\n  emphasis: `${CTX_VAR}.builtins.Emphasis`,\n  footnoteDefinition: `${CTX_VAR}.builtins.FootnoteDefinition`,\n  footnoteReference: `${CTX_VAR}.builtins.FootnoteReference`,\n  heading: `${CTX_VAR}.builtins.Heading`,\n  html: `${CTX_VAR}.builtins.HTML`,\n  image: `${CTX_VAR}.builtins.Image`,\n  imageReference: `${CTX_VAR}.builtins.ImageReference`,\n  inlineCode: `${CTX_VAR}.builtins.InlineCode`,\n  link: `${CTX_VAR}.builtins.Link`,\n  linkReference: `${CTX_VAR}.builtins.LinkReference`,\n  list: `${CTX_VAR}.builtins.List`,\n  listItem: `${CTX_VAR}.builtins.ListItem`,\n  paragraph: `${CTX_VAR}.builtins.Paragraph`,\n  root: `${CTX_VAR}.builtins.Root`,\n  strong: `${CTX_VAR}.builtins.Strong`,\n  table: `${CTX_VAR}.builtins.Table`,\n  tableCell: `${CTX_VAR}.builtins.TableCell`,\n  tableRow: `${CTX_VAR}.builtins.TableRow`,\n  thematicBreak: `${CTX_VAR}.builtins.ThematicBreak`,\n};\n\nfunction compileRoot(ctx: StateContext, node: mdast.Root): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.root;\n  result.add(`<${createTag(ctx, tag)}>`);\n  addContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileParagraph(ctx: StateContext, node: mdast.Paragraph): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.paragraph;\n  result.add(`<${createTag(ctx, tag)}>`);\n  addPhrasingContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileHeading(ctx: StateContext, node: mdast.Heading): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.heading;\n  const content = mdastString.toString(node, { includeImageAlt: false });\n  result.add(`<${createTag(ctx, tag)}`);\n  addJSAttribute(result, 'depth', node.depth.toString());\n  addStringAttribute(result, 'id', ctx.slugger.slug(content));\n  result.add('>');\n  addPhrasingContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileThematicBreak(ctx: StateContext, node: mdast.ThematicBreak): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(`<${createTag(ctx, MARKUP.thematicBreak)} />`);\n  return result;\n}\n\nfunction compileBlockquote(ctx: StateContext, node: mdast.Blockquote): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.blockquote;\n  result.add(`<${createTag(ctx, tag)}>`);\n  addBlockOrDefinitionContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileList(ctx: StateContext, node: mdast.List): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.list;\n  result.add(`<${createTag(ctx, tag)}`);\n  if (node.ordered != null) {\n    addJSAttribute(result, 'ordered', node.ordered.toString());\n  }\n  if (node.spread != null) {\n    addJSAttribute(result, 'spread', node.spread.toString());\n  }\n  if (node.start != null) {\n    addJSAttribute(result, 'start', node.start.toString());\n  }\n  result.add('>');\n  for (let i = 0, len = node.children.length; i < len; i += 1) {\n    result.add(compileListItem(ctx, node.children[i]));\n  }\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileListItem(ctx: StateContext, node: mdast.ListItem): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.listItem;\n  result.add(`<${createTag(ctx, tag)}`);\n  if (node.spread != null) {\n    addJSAttribute(result, 'spread', node.spread.toString());\n  }\n  if (node.checked != null) {\n    addJSAttribute(result, 'checked', node.checked.toString());\n  }\n  result.add('>');\n  addBlockOrDefinitionContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileHTML(ctx: StateContext, node: mdast.Html): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.html;\n  result.add(`<${createTag(ctx, tag)}>`);\n  result.add(`{${serializeString(node.value)}}`);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileCode(ctx: StateContext, node: mdast.Code): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.code;\n  result.add(`<${createTag(ctx, tag)}`);\n  if (node.lang) {\n    addStringAttribute(result, 'lang', node.lang);\n  }\n  if (node.meta) {\n    addStringAttribute(result, 'meta', node.meta);\n  }\n  result.add('>');\n  result.add(`{${serializeString(node.value)}}`);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileDefinition(ctx: StateContext, node: mdast.Definition): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(`<${createTag(ctx, MARKUP.definition)}`);\n  applyResource(result, node);\n  applyAssociation(result, node);\n  result.add(' />');\n  return result;\n}\n\nfunction compileText(ctx: StateContext, node: mdast.Text): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(node.value);\n  return result;\n}\n\nfunction compileEmphasis(ctx: StateContext, node: mdast.Emphasis): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.emphasis;\n  result.add(`<${createTag(ctx, tag)}>`);\n  addPhrasingContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileStrong(ctx: StateContext, node: mdast.Strong): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.strong;\n  result.add(`<${createTag(ctx, tag)}>`);\n  addPhrasingContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileInlineCode(ctx: StateContext, node: mdast.InlineCode): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.inlineCode;\n  result.add(`<${createTag(ctx, tag)}>`);\n  result.add(`{${serializeString(node.value)}}`);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileBreak(ctx: StateContext, node: mdast.Break): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(`<${createTag(ctx, MARKUP.break)} />`);\n  return result;\n}\n\nfunction compileLink(ctx: StateContext, node: mdast.Link): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.link;\n  result.add(`<${createTag(ctx, tag)}`);\n  applyResource(result, node);\n  result.add('>');\n  addPhrasingContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileImage(ctx: StateContext, node: mdast.Image): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(`<${createTag(ctx, MARKUP.image)}`);\n  applyResource(result, node);\n  applyAlternative(result, node);\n  result.add(' />');\n  return result;\n}\n\nfunction compileLinkReference(ctx: StateContext, node: mdast.LinkReference): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.linkReference;\n  result.add(`<${createTag(ctx, tag)}`);\n  applyReference(result, node);\n  result.add('>');\n  addPhrasingContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileImageReference(ctx: StateContext, node: mdast.ImageReference): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(`<${createTag(ctx, MARKUP.imageReference)}`);\n  applyReference(result, node);\n  applyAlternative(result, node);\n  result.add(' />');\n  return result;\n}\n\nfunction compileFootnoteDefinition(ctx: StateContext, node: mdast.FootnoteDefinition): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.footnoteDefinition;\n  result.add(`<${createTag(ctx, tag)}`);\n  applyAssociation(result, node);\n  result.add('>');\n  addBlockOrDefinitionContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileFootnoteReference(ctx: StateContext, node: mdast.FootnoteReference): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(`<${createTag(ctx, MARKUP.footnoteReference)}`);\n  applyAssociation(result, node);\n  result.add(' />');\n  return result;\n}\n\nfunction compileTable(ctx: StateContext, node: mdast.Table): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.table;\n  result.add(`<${createTag(ctx, tag)}`);\n  if (node.align != null) {\n    addJSAttribute(result, 'align', JSON.stringify(node.align));\n  }\n  result.add('>');\n  for (let i = 0, len = node.children.length; i < len; i += 1) {\n    result.add(compileTableRow(ctx, node.children[i], i === 0));\n  }\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileTableRow(ctx: StateContext, node: mdast.TableRow, isHead: boolean): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.tableRow;\n  result.add(`<${createTag(ctx, tag)}`);\n  if (isHead) {\n    addJSAttribute(result, 'isHead', 'true');\n  }\n  result.add('>');\n  for (let i = 0, len = node.children.length; i < len; i += 1) {\n    result.add(compileTableCell(ctx, node.children[i]));\n  }\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileTableCell(ctx: StateContext, node: mdast.TableCell): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.tableCell;\n  result.add(`<${createTag(ctx, tag)}>`);\n  addPhrasingContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileDelete(ctx: StateContext, node: mdast.Delete): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.delete;\n  result.add(`<${createTag(ctx, tag)}>`);\n  addPhrasingContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileMDXExpression(\n  ctx: StateContext,\n  node: mdastMDX.MdxTextExpression | mdastMDX.MdxFlowExpression,\n): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(`{${node.value}}`);\n  return result;\n}\n\nfunction compileMDXElement(\n  ctx: StateContext,\n  node: mdastMDX.MdxJsxTextElement | mdastMDX.MdxJsxFlowElement,\n): SourceNode {\n  const result = createSourceNode(ctx, node);\n  if (node.name) {\n    const name = createJSXTag(ctx, node.name);\n    result.add(`<${createTag(ctx, name, { isMDX: true })}`);\n    for (let i = 0, len = node.attributes.length; i < len; i += 1) {\n      const attribute = node.attributes[i];\n      const attributeNode = new SourceNode(\n        attribute.position?.start.line ?? null,\n        attribute.position?.start.column ?? null,\n        ctx.source,\n      );\n      if (attribute.type === 'mdxJsxAttribute') {\n        attributeNode.add(` ${attribute.name}`);\n        if (attribute.value) {\n          if (typeof attribute.value === 'string') {\n            attributeNode.add(`={${serializeString(attribute.value)}}`);\n          } else {\n            const attributeValueNode = new SourceNode(\n              attribute.value.position?.start.line ?? null,\n              attribute.value.position?.start.column ?? null,\n              ctx.source,\n            );\n            attributeValueNode.add(attribute.value.value);\n            attributeNode.add(['={', attributeValueNode, '}']);\n          }\n        }\n      } else {\n        attributeNode.add(` {...${attribute.value}}`);\n      }\n      result.add(attributeNode);\n    }\n    result.add('>');\n    addContent(ctx, result, node.children);\n    result.add(`</${createTag(ctx, name, { isClosing: true, isMDX: true })}>`);\n  } else {\n    result.add('<>');\n    addContent(ctx, result, node.children);\n    result.add('</>');\n  }\n  return result;\n}\n\nfunction compileMDXESM(ctx: StateContext, node: mdastMDX.MdxjsEsm): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(`${node.value}\\n`);\n  ctx.imports.push(result);\n  return new SourceNode();\n}\n\nfunction compileYAML(ctx: StateContext, node: mdast.Yaml): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(seroval.serialize(\n    yaml.parse(node.value),\n  ));\n  ctx.frontmatter = result;\n  return new SourceNode();\n}\n\nfunction compileTOML(ctx: StateContext, node: TOML): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(seroval.serialize(\n    toml.parse(node.value),\n  ));\n  ctx.frontmatter = result;\n  return new SourceNode();\n}\n\nfunction compileBlockOrDefinitionContent(\n  ctx: StateContext,\n  node: mdast.BlockContent | mdast.DefinitionContent,\n): SourceNode {\n  switch (node.type) {\n    case 'blockquote':\n      return compileBlockquote(ctx, node);\n    case 'code':\n      return compileCode(ctx, node);\n    case 'heading':\n      return compileHeading(ctx, node);\n    case 'html':\n      return compileHTML(ctx, node);\n    case 'list':\n      return compileList(ctx, node);\n    case 'mdxFlowExpression':\n      return compileMDXExpression(ctx, node);\n    case 'mdxJsxFlowElement':\n      return compileMDXElement(ctx, node);\n    case 'paragraph':\n      return compileParagraph(ctx, node);\n    case 'table':\n      return compileTable(ctx, node);\n    case 'thematicBreak':\n      return compileThematicBreak(ctx, node);\n    case 'definition':\n      return compileDefinition(ctx, node);\n    case 'footnoteDefinition':\n      return compileFootnoteDefinition(ctx, node);\n    default:\n      throw new Error('invariant');\n  }\n}\n\nfunction compilePhrasingContent(\n  ctx: StateContext,\n  node: mdast.PhrasingContent,\n): SourceNode {\n  switch (node.type) {\n    case 'break':\n      return compileBreak(ctx, node);\n    case 'delete':\n      return compileDelete(ctx, node);\n    case 'emphasis':\n      return compileEmphasis(ctx, node);\n    case 'footnoteReference':\n      return compileFootnoteReference(ctx, node);\n    case 'html':\n      return compileHTML(ctx, node);\n    case 'image':\n      return compileImage(ctx, node);\n    case 'imageReference':\n      return compileImageReference(ctx, node);\n    case 'inlineCode':\n      return compileInlineCode(ctx, node);\n    case 'mdxJsxTextElement':\n      return compileMDXElement(ctx, node);\n    case 'mdxTextExpression':\n      return compileMDXExpression(ctx, node);\n    case 'strong':\n      return compileStrong(ctx, node);\n    case 'text':\n      return compileText(ctx, node);\n    case 'link':\n      return compileLink(ctx, node);\n    case 'linkReference':\n      return compileLinkReference(ctx, node);\n    default:\n      throw new Error('invariant');\n  }\n}\n\nfunction addPhrasingContent(\n  ctx: StateContext,\n  source: SourceNode,\n  nodes: mdast.PhrasingContent[],\n): void {\n  for (let i = 0, len = nodes.length; i < len; i += 1) {\n    source.add(compilePhrasingContent(ctx, nodes[i]));\n  }\n}\n\nfunction addBlockOrDefinitionContent(\n  ctx: StateContext,\n  source: SourceNode,\n  nodes: (mdast.BlockContent | mdast.DefinitionContent)[],\n): void {\n  for (let i = 0, len = nodes.length; i < len; i += 1) {\n    source.add(compileBlockOrDefinitionContent(ctx, nodes[i]));\n  }\n}\n\nexport function compileNode(\n  ctx: StateContext,\n  node: mdast.Nodes,\n): SourceNode {\n  switch (node.type) {\n    case 'root':\n      return compileRoot(ctx, node);\n    case 'paragraph':\n      return compileParagraph(ctx, node);\n    case 'heading':\n      return compileHeading(ctx, node);\n    case 'thematicBreak':\n      return compileThematicBreak(ctx, node);\n    case 'blockquote':\n      return compileBlockquote(ctx, node);\n    case 'list':\n      return compileList(ctx, node);\n    case 'listItem':\n      return compileListItem(ctx, node);\n    case 'code':\n      return compileCode(ctx, node);\n    case 'definition':\n      return compileDefinition(ctx, node);\n    case 'text':\n      return compileText(ctx, node);\n    case 'emphasis':\n      return compileEmphasis(ctx, node);\n    case 'strong':\n      return compileStrong(ctx, node);\n    case 'inlineCode':\n      return compileInlineCode(ctx, node);\n    case 'break':\n      return compileBreak(ctx, node);\n    case 'link':\n      return compileLink(ctx, node);\n    case 'image':\n      return compileImage(ctx, node);\n    case 'linkReference':\n      return compileLinkReference(ctx, node);\n    case 'imageReference':\n      return compileImageReference(ctx, node);\n    case 'footnoteDefinition':\n      return compileFootnoteDefinition(ctx, node);\n    case 'footnoteReference':\n      return compileFootnoteReference(ctx, node);\n    case 'table':\n      return compileTable(ctx, node);\n    case 'tableCell':\n      return compileTableCell(ctx, node);\n    case 'tableRow':\n      return compileTableRow(ctx, node, false);\n    case 'delete':\n      return compileDelete(ctx, node);\n    case 'mdxTextExpression':\n    case 'mdxFlowExpression':\n      return compileMDXExpression(ctx, node);\n    case 'mdxJsxTextElement':\n    case 'mdxJsxFlowElement':\n      return compileMDXElement(ctx, node);\n    case 'mdxjsEsm':\n      return compileMDXESM(ctx, node);\n    case 'yaml':\n      return compileYAML(ctx, node);\n    case 'toml':\n      return compileTOML(ctx, node);\n    default:\n      throw new Error('Invalid node type');\n  }\n}\n\nfunction addContent(\n  ctx: StateContext,\n  source: SourceNode,\n  nodes: mdast.RootContent[],\n): void {\n  for (let i = 0, len = nodes.length; i < len; i += 1) {\n    source.add(compileNode(ctx, nodes[i]));\n  }\n}\n", "export function serializeChar(str: string): string | undefined {\n  switch (str) {\n    case '\"': return '\\\\\"';\n    case '\\\\': return '\\\\\\\\';\n    case '\\n': return '\\\\n';\n    case '\\r': return '\\\\r';\n    case '\\b': return '\\\\b';\n    case '\\t': return '\\\\t';\n    case '\\f': return '\\\\f';\n    case '<': return '\\\\x3C';\n    case '\\u2028': return '\\\\u2028';\n    case '\\u2029': return '\\\\u2029';\n    default: return undefined;\n  }\n}\n\n// Written by https://github.com/DylanPiercey and is distributed under the MIT license.\n// Creates a JavaScript double quoted string and escapes all characters\n// not listed as DoubleStringCharacters on\n// Also includes \"<\" to escape \"</script>\" and \"\\\" to avoid invalid escapes in the output.\n// http://www.ecma-international.org/ecma-262/5.1/#sec-7.8.4\nexport function serializeString(str: string): string {\n  let result = '';\n  let lastPos = 0;\n  let replacement: string | undefined;\n  for (let i = 0, len = str.length; i < len; i += 1) {\n    replacement = serializeChar(str[i]);\n    if (replacement) {\n      result += str.slice(lastPos, i) + replacement;\n      lastPos = i + 1;\n    }\n  }\n  if (lastPos === 0) {\n    result = str;\n  } else {\n    result += str.slice(lastPos);\n  }\n  return `\"${result}\"`;\n}\n"],
+  "sourcesContent": ["import type { RawSourceMap } from 'source-map';\nimport {\n  SourceNode,\n} from 'source-map';\nimport {\n  fromMarkdown,\n} from 'mdast-util-from-markdown';\nimport { mdxFromMarkdown } from 'mdast-util-mdx';\nimport { gfmFromMarkdown } from 'mdast-util-gfm';\nimport { frontmatterFromMarkdown } from 'mdast-util-frontmatter';\nimport { toc } from 'mdast-util-toc';\nimport { mdxjs } from 'micromark-extension-mdxjs';\nimport { gfm } from 'micromark-extension-gfm';\nimport { frontmatter } from 'micromark-extension-frontmatter';\nimport GithubSlugger from 'github-slugger';\nimport { CTX_VAR, compileNode } from './compiler';\nimport type { Options, StateContext } from './types';\n\nexport type { Options } from './types';\nexport * from './interfaces';\n\nconst USE_MDX_VAR = '_useMDX$';\n\nexport interface Result {\n  code: string;\n  map: RawSourceMap;\n}\n\nexport function compile(\n  fileName: string,\n  markdownCode: string,\n  options: Options = {},\n): Result {\n  const ast = fromMarkdown(markdownCode, {\n    extensions: [\n      mdxjs(),\n      gfm(),\n      frontmatter(['yaml', 'toml']),\n    ],\n    mdastExtensions: [\n      mdxFromMarkdown(),\n      gfmFromMarkdown(),\n      frontmatterFromMarkdown(['yaml', 'toml']),\n    ],\n  });\n\n  const tocAST = toc(ast, { parents: () => true });\n\n  const ctx: StateContext = {\n    source: fileName,\n    options,\n    imports: [],\n    frontmatter: undefined,\n    slugger: new GithubSlugger(),\n  };\n  const render = compileNode(ctx, ast);\n\n  const compiled = new SourceNode(null, null, fileName);\n\n  compiled.add(ctx.imports);\n  if (ctx.frontmatter) {\n    compiled.add('export const frontmatter = ');\n    compiled.add(ctx.frontmatter);\n    compiled.add(';\\n');\n  }\n  compiled.add(`import { useMDX as ${USE_MDX_VAR} } from '${options.mdxImportSource || 'solid-marked'}';\\n\\n`);\n  if (tocAST.map) {\n    const renderedTOC = compileNode(ctx, tocAST.map);\n    compiled.add('export function TableOfContents(props) {\\n');\n    compiled.add(`  const ${CTX_VAR} = ${USE_MDX_VAR}();\\n`);\n    compiled.add('  return (\\n');\n    compiled.add(renderedTOC);\n    compiled.add('\\n  );\\n');\n    compiled.add('}\\n');\n  }\n  compiled.add('export default function Component(props) {\\n');\n  compiled.add(`  const ${CTX_VAR} = ${USE_MDX_VAR}();\\n`);\n  compiled.add('  return (\\n');\n  compiled.add(render);\n  compiled.add('\\n  );\\n');\n  compiled.add('}\\n');\n\n  compiled.setSourceContent(fileName, markdownCode);\n\n  const compiledResult = compiled.toStringWithSourceMap();\n\n  return {\n    code: compiledResult.code,\n    map: compiledResult.map.toJSON(),\n  };\n}\n", "/* eslint-disable @typescript-eslint/no-use-before-define */\nimport type * as mdast from 'mdast';\nimport * as mdastString from 'mdast-util-to-string';\nimport { SourceNode } from 'source-map';\nimport type * as mdastMDX from 'mdast-util-mdx';\nimport * as seroval from 'seroval';\nimport * as yaml from 'yaml';\nimport * as toml from 'toml';\nimport type { StateContext } from './types';\nimport { serializeString } from './string';\n\ninterface TOML extends mdast.Literal {\n  type: 'toml';\n}\n\ndeclare module 'mdast' {\n  // Allow using TOML nodes defined by `mdast-util-frontmatter`.\n  interface FrontmatterContentMap {\n    toml: TOML;\n  }\n  interface RootContentMap {\n    toml: TOML;\n  }\n}\n\nfunction createSourceNode(ctx: StateContext, base: mdast.Nodes): SourceNode {\n  const col = base.position?.start.column;\n  return new SourceNode(\n    base.position?.start.line ?? null,\n    col != null ? col - 1 : null,\n    ctx.source,\n  );\n}\n\nfunction addStringAttribute(result: SourceNode, name: string, value: string): void {\n  result.add(` ${name}={${serializeString(value)}}`);\n}\nfunction addJSAttribute(result: SourceNode, name: string, expression: string): void {\n  result.add(` ${name}={${expression}}`);\n}\n\nfunction applyAssociation(result: SourceNode, node: mdast.Association): void {\n  addStringAttribute(result, 'identifier', node.identifier);\n  if (node.label) {\n    addStringAttribute(result, 'label', node.label);\n  }\n}\n\nfunction applyResource(result: SourceNode, node: mdast.Resource): void {\n  addStringAttribute(result, 'url', node.url);\n  if (node.title) {\n    addStringAttribute(result, 'title', node.title);\n  }\n}\n\nfunction applyAlternative(result: SourceNode, node: mdast.Alternative): void {\n  if (node.alt) {\n    addStringAttribute(result, 'alt', node.alt);\n  }\n}\n\nfunction applyReference(result: SourceNode, node: mdast.Reference): void {\n  applyAssociation(result, node);\n  addStringAttribute(result, 'referenceType', node.referenceType);\n}\n\ninterface TagOptions {\n  isClosing?: boolean;\n  isMDX?: boolean;\n}\n\nfunction createTag(ctx: StateContext, target: string, tagOpts: TagOptions = {}): string {\n  if (ctx.options.noDynamicComponents === 'only-mdx' && tagOpts.isMDX) {\n    return target;\n  }\n  if (ctx.options.noDynamicComponents === true) {\n    return target;\n  }\n  if (tagOpts.isClosing) {\n    return 'Dynamic';\n  }\n\n  return `Dynamic component={${target}}`;\n}\n\nfunction createJSXTag(\n  ctx: StateContext,\n  nodeName: string,\n): string {\n  if (ctx.options.noDynamicComponents) {\n    return nodeName;\n  }\n  // Test for dashed elements\n  if (/^[a-zA-Z0-9]+(-[a-zA-Z0-9]+)+$/.test(nodeName)) {\n    return `_ctx$.components['${nodeName}']`;\n  }\n  if (/^[a-zA-Z0-9]+:[a-zA-Z0-9]+$/.test(nodeName)) {\n    return `_ctx$.components['${nodeName}']`;\n  }\n  return `typeof ${nodeName} === 'undefined' ? _ctx$.components.${nodeName} : ${nodeName}`;\n}\n\ntype ExcludedTags =\n  | 'mdxFlowExpression'\n  | 'mdxjsEsm'\n  | 'mdxJsxFlowElement'\n  | 'mdxJsxTextElement'\n  | 'mdxTextExpression'\n  | 'text'\n  | 'yaml'\n  | 'toml';\ntype WithTags = Exclude<mdast.Nodes['type'], ExcludedTags>\n\nexport const CTX_VAR = '_ctx$';\n\nconst MARKUP: Record<WithTags, string> = {\n  blockquote: `${CTX_VAR}.builtins.Blockquote`,\n  break: `${CTX_VAR}.builtins.Break`,\n  code: `${CTX_VAR}.builtins.Code`,\n  definition: `${CTX_VAR}.builtins.Definition`,\n  delete: `${CTX_VAR}.builtins.Delete`,\n  emphasis: `${CTX_VAR}.builtins.Emphasis`,\n  footnoteDefinition: `${CTX_VAR}.builtins.FootnoteDefinition`,\n  footnoteReference: `${CTX_VAR}.builtins.FootnoteReference`,\n  heading: `${CTX_VAR}.builtins.Heading`,\n  html: `${CTX_VAR}.builtins.HTML`,\n  image: `${CTX_VAR}.builtins.Image`,\n  imageReference: `${CTX_VAR}.builtins.ImageReference`,\n  inlineCode: `${CTX_VAR}.builtins.InlineCode`,\n  link: `${CTX_VAR}.builtins.Link`,\n  linkReference: `${CTX_VAR}.builtins.LinkReference`,\n  list: `${CTX_VAR}.builtins.List`,\n  listItem: `${CTX_VAR}.builtins.ListItem`,\n  paragraph: `${CTX_VAR}.builtins.Paragraph`,\n  root: `${CTX_VAR}.builtins.Root`,\n  strong: `${CTX_VAR}.builtins.Strong`,\n  table: `${CTX_VAR}.builtins.Table`,\n  tableCell: `${CTX_VAR}.builtins.TableCell`,\n  tableRow: `${CTX_VAR}.builtins.TableRow`,\n  thematicBreak: `${CTX_VAR}.builtins.ThematicBreak`,\n};\n\nfunction compileRoot(ctx: StateContext, node: mdast.Root): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.root;\n  result.add(`<${createTag(ctx, tag)}>`);\n  addContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileParagraph(ctx: StateContext, node: mdast.Paragraph): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.paragraph;\n  result.add(`<${createTag(ctx, tag)}>`);\n  addPhrasingContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileHeading(ctx: StateContext, node: mdast.Heading): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.heading;\n  const content = mdastString.toString(node, { includeImageAlt: false });\n  result.add(`<${createTag(ctx, tag)}`);\n  addJSAttribute(result, 'depth', node.depth.toString());\n  addStringAttribute(result, 'id', ctx.slugger.slug(content));\n  result.add('>');\n  addPhrasingContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileThematicBreak(ctx: StateContext, node: mdast.ThematicBreak): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(`<${createTag(ctx, MARKUP.thematicBreak)} />`);\n  return result;\n}\n\nfunction compileBlockquote(ctx: StateContext, node: mdast.Blockquote): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.blockquote;\n  result.add(`<${createTag(ctx, tag)}>`);\n  addBlockOrDefinitionContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileList(ctx: StateContext, node: mdast.List): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.list;\n  result.add(`<${createTag(ctx, tag)}`);\n  if (node.ordered != null) {\n    addJSAttribute(result, 'ordered', node.ordered.toString());\n  }\n  if (node.spread != null) {\n    addJSAttribute(result, 'spread', node.spread.toString());\n  }\n  if (node.start != null) {\n    addJSAttribute(result, 'start', node.start.toString());\n  }\n  result.add('>');\n  for (let i = 0, len = node.children.length; i < len; i += 1) {\n    result.add(compileListItem(ctx, node.children[i]));\n  }\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileListItem(ctx: StateContext, node: mdast.ListItem): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.listItem;\n  result.add(`<${createTag(ctx, tag)}`);\n  if (node.spread != null) {\n    addJSAttribute(result, 'spread', node.spread.toString());\n  }\n  if (node.checked != null) {\n    addJSAttribute(result, 'checked', node.checked.toString());\n  }\n  result.add('>');\n  addBlockOrDefinitionContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileHTML(ctx: StateContext, node: mdast.Html): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.html;\n  result.add(`<${createTag(ctx, tag)}>`);\n  result.add(`{${serializeString(node.value)}}`);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileCode(ctx: StateContext, node: mdast.Code): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.code;\n  result.add(`<${createTag(ctx, tag)}`);\n  if (node.lang) {\n    addStringAttribute(result, 'lang', node.lang);\n  }\n  if (node.meta) {\n    addStringAttribute(result, 'meta', node.meta);\n  }\n  result.add('>');\n  result.add(`{${serializeString(node.value)}}`);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileDefinition(ctx: StateContext, node: mdast.Definition): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(`<${createTag(ctx, MARKUP.definition)}`);\n  applyResource(result, node);\n  applyAssociation(result, node);\n  result.add(' />');\n  return result;\n}\n\nfunction compileText(ctx: StateContext, node: mdast.Text): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(node.value);\n  return result;\n}\n\nfunction compileEmphasis(ctx: StateContext, node: mdast.Emphasis): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.emphasis;\n  result.add(`<${createTag(ctx, tag)}>`);\n  addPhrasingContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileStrong(ctx: StateContext, node: mdast.Strong): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.strong;\n  result.add(`<${createTag(ctx, tag)}>`);\n  addPhrasingContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileInlineCode(ctx: StateContext, node: mdast.InlineCode): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.inlineCode;\n  result.add(`<${createTag(ctx, tag)}>`);\n  result.add(`{${serializeString(node.value)}}`);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileBreak(ctx: StateContext, node: mdast.Break): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(`<${createTag(ctx, MARKUP.break)} />`);\n  return result;\n}\n\nfunction compileLink(ctx: StateContext, node: mdast.Link): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.link;\n  result.add(`<${createTag(ctx, tag)}`);\n  applyResource(result, node);\n  result.add('>');\n  addPhrasingContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileImage(ctx: StateContext, node: mdast.Image): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(`<${createTag(ctx, MARKUP.image)}`);\n  applyResource(result, node);\n  applyAlternative(result, node);\n  result.add(' />');\n  return result;\n}\n\nfunction compileLinkReference(ctx: StateContext, node: mdast.LinkReference): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.linkReference;\n  result.add(`<${createTag(ctx, tag)}`);\n  applyReference(result, node);\n  result.add('>');\n  addPhrasingContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileImageReference(ctx: StateContext, node: mdast.ImageReference): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(`<${createTag(ctx, MARKUP.imageReference)}`);\n  applyReference(result, node);\n  applyAlternative(result, node);\n  result.add(' />');\n  return result;\n}\n\nfunction compileFootnoteDefinition(ctx: StateContext, node: mdast.FootnoteDefinition): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.footnoteDefinition;\n  result.add(`<${createTag(ctx, tag)}`);\n  applyAssociation(result, node);\n  result.add('>');\n  addBlockOrDefinitionContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileFootnoteReference(ctx: StateContext, node: mdast.FootnoteReference): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(`<${createTag(ctx, MARKUP.footnoteReference)}`);\n  applyAssociation(result, node);\n  result.add(' />');\n  return result;\n}\n\nfunction compileTable(ctx: StateContext, node: mdast.Table): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.table;\n  result.add(`<${createTag(ctx, tag)}`);\n  if (node.align != null) {\n    addJSAttribute(result, 'align', JSON.stringify(node.align));\n  }\n  result.add('>');\n  for (let i = 0, len = node.children.length; i < len; i += 1) {\n    result.add(compileTableRow(ctx, node.children[i], i === 0));\n  }\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileTableRow(ctx: StateContext, node: mdast.TableRow, isHead: boolean): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.tableRow;\n  result.add(`<${createTag(ctx, tag)}`);\n  if (isHead) {\n    addJSAttribute(result, 'isHead', 'true');\n  }\n  result.add('>');\n  for (let i = 0, len = node.children.length; i < len; i += 1) {\n    result.add(compileTableCell(ctx, node.children[i]));\n  }\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileTableCell(ctx: StateContext, node: mdast.TableCell): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.tableCell;\n  result.add(`<${createTag(ctx, tag)}>`);\n  addPhrasingContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileDelete(ctx: StateContext, node: mdast.Delete): SourceNode {\n  const result = createSourceNode(ctx, node);\n  const tag = MARKUP.delete;\n  result.add(`<${createTag(ctx, tag)}>`);\n  addPhrasingContent(ctx, result, node.children);\n  result.add(`</${createTag(ctx, tag, { isClosing: true })}>`);\n  return result;\n}\n\nfunction compileMDXExpression(\n  ctx: StateContext,\n  node: mdastMDX.MdxTextExpression | mdastMDX.MdxFlowExpression,\n): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(`{${node.value}}`);\n  return result;\n}\n\nfunction compileMDXElement(\n  ctx: StateContext,\n  node: mdastMDX.MdxJsxTextElement | mdastMDX.MdxJsxFlowElement,\n): SourceNode {\n  const result = createSourceNode(ctx, node);\n  if (node.name) {\n    const name = createJSXTag(ctx, node.name);\n    result.add(`<${createTag(ctx, name, { isMDX: true })}`);\n    for (let i = 0, len = node.attributes.length; i < len; i += 1) {\n      const attribute = node.attributes[i];\n      const attributeNode = new SourceNode(\n        attribute.position?.start.line ?? null,\n        attribute.position?.start.column ?? null,\n        ctx.source,\n      );\n      if (attribute.type === 'mdxJsxAttribute') {\n        attributeNode.add(` ${attribute.name}`);\n        if (attribute.value) {\n          if (typeof attribute.value === 'string') {\n            attributeNode.add(`={${serializeString(attribute.value)}}`);\n          } else {\n            const attributeValueNode = new SourceNode(\n              attribute.value.position?.start.line ?? null,\n              attribute.value.position?.start.column ?? null,\n              ctx.source,\n            );\n            attributeValueNode.add(attribute.value.value);\n            attributeNode.add(['={', attributeValueNode, '}']);\n          }\n        }\n      } else {\n        attributeNode.add(` {...${attribute.value}}`);\n      }\n      result.add(attributeNode);\n    }\n    result.add('>');\n    addContent(ctx, result, node.children);\n    result.add(`</${createTag(ctx, name, { isClosing: true, isMDX: true })}>`);\n  } else {\n    result.add('<>');\n    addContent(ctx, result, node.children);\n    result.add('</>');\n  }\n  return result;\n}\n\nfunction compileMDXESM(ctx: StateContext, node: mdastMDX.MdxjsEsm): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(`${node.value}\\n`);\n  ctx.imports.push(result);\n  return new SourceNode();\n}\n\nfunction compileYAML(ctx: StateContext, node: mdast.Yaml): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(seroval.serialize(\n    yaml.parse(node.value),\n  ));\n  ctx.frontmatter = result;\n  return new SourceNode();\n}\n\nfunction compileTOML(ctx: StateContext, node: TOML): SourceNode {\n  const result = createSourceNode(ctx, node);\n  result.add(seroval.serialize(\n    toml.parse(node.value),\n  ));\n  ctx.frontmatter = result;\n  return new SourceNode();\n}\n\nfunction compileBlockOrDefinitionContent(\n  ctx: StateContext,\n  node: mdast.BlockContent | mdast.DefinitionContent,\n): SourceNode {\n  switch (node.type) {\n    case 'blockquote':\n      return compileBlockquote(ctx, node);\n    case 'code':\n      return compileCode(ctx, node);\n    case 'heading':\n      return compileHeading(ctx, node);\n    case 'html':\n      return compileHTML(ctx, node);\n    case 'list':\n      return compileList(ctx, node);\n    case 'mdxFlowExpression':\n      return compileMDXExpression(ctx, node);\n    case 'mdxJsxFlowElement':\n      return compileMDXElement(ctx, node);\n    case 'paragraph':\n      return compileParagraph(ctx, node);\n    case 'table':\n      return compileTable(ctx, node);\n    case 'thematicBreak':\n      return compileThematicBreak(ctx, node);\n    case 'definition':\n      return compileDefinition(ctx, node);\n    case 'footnoteDefinition':\n      return compileFootnoteDefinition(ctx, node);\n    default:\n      throw new Error('invariant');\n  }\n}\n\nfunction compilePhrasingContent(\n  ctx: StateContext,\n  node: mdast.PhrasingContent,\n): SourceNode {\n  switch (node.type) {\n    case 'break':\n      return compileBreak(ctx, node);\n    case 'delete':\n      return compileDelete(ctx, node);\n    case 'emphasis':\n      return compileEmphasis(ctx, node);\n    case 'footnoteReference':\n      return compileFootnoteReference(ctx, node);\n    case 'html':\n      return compileHTML(ctx, node);\n    case 'image':\n      return compileImage(ctx, node);\n    case 'imageReference':\n      return compileImageReference(ctx, node);\n    case 'inlineCode':\n      return compileInlineCode(ctx, node);\n    case 'mdxJsxTextElement':\n      return compileMDXElement(ctx, node);\n    case 'mdxTextExpression':\n      return compileMDXExpression(ctx, node);\n    case 'strong':\n      return compileStrong(ctx, node);\n    case 'text':\n      return compileText(ctx, node);\n    case 'link':\n      return compileLink(ctx, node);\n    case 'linkReference':\n      return compileLinkReference(ctx, node);\n    default:\n      throw new Error('invariant');\n  }\n}\n\nfunction addPhrasingContent(\n  ctx: StateContext,\n  source: SourceNode,\n  nodes: mdast.PhrasingContent[],\n): void {\n  for (let i = 0, len = nodes.length; i < len; i += 1) {\n    source.add(compilePhrasingContent(ctx, nodes[i]));\n  }\n}\n\nfunction addBlockOrDefinitionContent(\n  ctx: StateContext,\n  source: SourceNode,\n  nodes: (mdast.BlockContent | mdast.DefinitionContent)[],\n): void {\n  for (let i = 0, len = nodes.length; i < len; i += 1) {\n    source.add(compileBlockOrDefinitionContent(ctx, nodes[i]));\n  }\n}\n\nexport function compileNode(\n  ctx: StateContext,\n  node: mdast.Nodes,\n): SourceNode {\n  switch (node.type) {\n    case 'root':\n      return compileRoot(ctx, node);\n    case 'paragraph':\n      return compileParagraph(ctx, node);\n    case 'heading':\n      return compileHeading(ctx, node);\n    case 'thematicBreak':\n      return compileThematicBreak(ctx, node);\n    case 'blockquote':\n      return compileBlockquote(ctx, node);\n    case 'list':\n      return compileList(ctx, node);\n    case 'listItem':\n      return compileListItem(ctx, node);\n    case 'code':\n      return compileCode(ctx, node);\n    case 'definition':\n      return compileDefinition(ctx, node);\n    case 'text':\n      return compileText(ctx, node);\n    case 'emphasis':\n      return compileEmphasis(ctx, node);\n    case 'strong':\n      return compileStrong(ctx, node);\n    case 'inlineCode':\n      return compileInlineCode(ctx, node);\n    case 'break':\n      return compileBreak(ctx, node);\n    case 'link':\n      return compileLink(ctx, node);\n    case 'image':\n      return compileImage(ctx, node);\n    case 'linkReference':\n      return compileLinkReference(ctx, node);\n    case 'imageReference':\n      return compileImageReference(ctx, node);\n    case 'footnoteDefinition':\n      return compileFootnoteDefinition(ctx, node);\n    case 'footnoteReference':\n      return compileFootnoteReference(ctx, node);\n    case 'table':\n      return compileTable(ctx, node);\n    case 'tableCell':\n      return compileTableCell(ctx, node);\n    case 'tableRow':\n      return compileTableRow(ctx, node, false);\n    case 'delete':\n      return compileDelete(ctx, node);\n    case 'mdxTextExpression':\n    case 'mdxFlowExpression':\n      return compileMDXExpression(ctx, node);\n    case 'mdxJsxTextElement':\n    case 'mdxJsxFlowElement':\n      return compileMDXElement(ctx, node);\n    case 'mdxjsEsm':\n      return compileMDXESM(ctx, node);\n    case 'yaml':\n      return compileYAML(ctx, node);\n    case 'toml':\n      return compileTOML(ctx, node);\n    default:\n      throw new Error('Invalid node type');\n  }\n}\n\nfunction addContent(\n  ctx: StateContext,\n  source: SourceNode,\n  nodes: mdast.RootContent[],\n): void {\n  for (let i = 0, len = nodes.length; i < len; i += 1) {\n    source.add(compileNode(ctx, nodes[i]));\n  }\n}\n", "export function serializeChar(str: string): string | undefined {\n  switch (str) {\n    case '\"': return '\\\\\"';\n    case '\\\\': return '\\\\\\\\';\n    case '\\n': return '\\\\n';\n    case '\\r': return '\\\\r';\n    case '\\b': return '\\\\b';\n    case '\\t': return '\\\\t';\n    case '\\f': return '\\\\f';\n    case '<': return '\\\\x3C';\n    case '\\u2028': return '\\\\u2028';\n    case '\\u2029': return '\\\\u2029';\n    default: return undefined;\n  }\n}\n\n// Written by https://github.com/DylanPiercey and is distributed under the MIT license.\n// Creates a JavaScript double quoted string and escapes all characters\n// not listed as DoubleStringCharacters on\n// Also includes \"<\" to escape \"</script>\" and \"\\\" to avoid invalid escapes in the output.\n// http://www.ecma-international.org/ecma-262/5.1/#sec-7.8.4\nexport function serializeString(str: string): string {\n  let result = '';\n  let lastPos = 0;\n  let replacement: string | undefined;\n  for (let i = 0, len = str.length; i < len; i += 1) {\n    replacement = serializeChar(str[i]);\n    if (replacement) {\n      result += str.slice(lastPos, i) + replacement;\n      lastPos = i + 1;\n    }\n  }\n  if (lastPos === 0) {\n    result = str;\n  } else {\n    result += str.slice(lastPos);\n  }\n  return `\"${result}\"`;\n}\n"],
   "mappings": "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",
   "names": ["SourceNode", "SourceNode"]
 }
diff --git a/dist/esm/production/compiler.mjs b/dist/esm/production/compiler.mjs
index 1c9d67afa6de06704c663c5c969be9be2273ac42..29bb39c21b1c41b3f434734f74d25e633e7de09c 100644
--- a/dist/esm/production/compiler.mjs
+++ b/dist/esm/production/compiler.mjs
@@ -1,6 +1,6 @@
 import{SourceNode as $e}from"source-map";import{fromMarkdown as he}from"mdast-util-from-markdown";import{mdxFromMarkdown as be}from"mdast-util-mdx";import{gfmFromMarkdown as ke}from"mdast-util-gfm";import{frontmatterFromMarkdown as Ne}from"mdast-util-frontmatter";import{toc as Re}from"mdast-util-toc";import{mdxjs as Te}from"micromark-extension-mdxjs";import{gfm as Me}from"micromark-extension-gfm";import{frontmatter as ye}from"micromark-extension-frontmatter";import De from"github-slugger";import*as F from"mdast-util-to-string";import{SourceNode as C}from"source-map";import*as M from"seroval";import*as I from"yaml";import*as B from"toml";function de(t){switch(t){case'"':return'\\"';case"\\":return"\\\\";case`
-`:return"\\n";case"\r":return"\\r";case"\b":return"\\b";case"	":return"\\t";case"\f":return"\\f";case"<":return"\\x3C";case"\u2028":return"\\u2028";case"\u2029":return"\\u2029";default:return}}function S(t){let e="",r=0,n;for(let i=0,d=t.length;i<d;i+=1)n=de(t[i]),n&&(e+=t.slice(r,i)+n,r=i+1);return r===0?e=t:e+=t.slice(r),`"${e}"`}function a(t,e){var n,i,d;let r=(n=e.position)==null?void 0:n.start.column;return new C((d=(i=e.position)==null?void 0:i.start.line)!=null?d:null,r!=null?r-1:null,t.source)}function m(t,e,r){t.add(` ${e}={${S(r)}}`)}function f(t,e,r){t.add(` ${e}={${r}}`)}function k(t,e){m(t,"identifier",e.identifier),e.label&&m(t,"label",e.label)}function y(t,e){m(t,"url",e.url),e.title&&m(t,"title",e.title)}function O(t,e){e.alt&&m(t,"alt",e.alt)}function J(t,e){k(t,e),m(t,"referenceType",e.referenceType)}function o(t,e,r={}){return t.options.noDynamicComponents==="only-mdx"&&r.isMDX||t.options.noDynamicComponents===!0?e:r.isClosing?"Dynamic":`Dynamic component={${e}}`}function ce(t,e){return t.options.noDynamicComponents?e:/^[a-zA-Z0-9]+(-[a-zA-Z0-9]+)+$/.test(e)?`__ctx.components['${e}']`:/^[a-zA-Z0-9]+:[a-zA-Z0-9]+$/.test(e)?`__ctx.components['${e}']`:`typeof ${e} === 'undefined' ? __ctx.components.${e} : ${e}`}var s="_ctx$",l={blockquote:`${s}.builtins.Blockquote`,break:`${s}.builtins.Break`,code:`${s}.builtins.Code`,definition:`${s}.builtins.Definition`,delete:`${s}.builtins.Delete`,emphasis:`${s}.builtins.Emphasis`,footnoteDefinition:`${s}.builtins.FootnoteDefinition`,footnoteReference:`${s}.builtins.FootnoteReference`,heading:`${s}.builtins.Heading`,html:`${s}.builtins.HTML`,image:`${s}.builtins.Image`,imageReference:`${s}.builtins.ImageReference`,inlineCode:`${s}.builtins.InlineCode`,link:`${s}.builtins.Link`,linkReference:`${s}.builtins.LinkReference`,list:`${s}.builtins.List`,listItem:`${s}.builtins.ListItem`,paragraph:`${s}.builtins.Paragraph`,root:`${s}.builtins.Root`,strong:`${s}.builtins.Strong`,table:`${s}.builtins.Table`,tableCell:`${s}.builtins.TableCell`,tableRow:`${s}.builtins.TableRow`,thematicBreak:`${s}.builtins.ThematicBreak`};function me(t,e){let r=a(t,e),n=l.root;return r.add(`<${o(t,n)}>`),T(t,r,e.children),r.add(`</${o(t,n,{isClosing:!0})}>`),r}function _(t,e){let r=a(t,e),n=l.paragraph;return r.add(`<${o(t,n)}>`),p(t,r,e.children),r.add(`</${o(t,n,{isClosing:!0})}>`),r}function z(t,e){let r=a(t,e),n=l.heading,i=F.toString(e,{includeImageAlt:!1});return r.add(`<${o(t,n)}`),f(r,"depth",e.depth.toString()),m(r,"id",t.slugger.slug(i)),r.add(">"),p(t,r,e.children),r.add(`</${o(t,n,{isClosing:!0})}>`),r}function P(t,e){let r=a(t,e);return r.add(`<${o(t,l.thematicBreak)} />`),r}function q(t,e){let r=a(t,e),n=l.blockquote;return r.add(`<${o(t,n)}>`),v(t,r,e.children),r.add(`</${o(t,n,{isClosing:!0})}>`),r}function H(t,e){let r=a(t,e),n=l.list;r.add(`<${o(t,n)}`),e.ordered!=null&&f(r,"ordered",e.ordered.toString()),e.spread!=null&&f(r,"spread",e.spread.toString()),e.start!=null&&f(r,"start",e.start.toString()),r.add(">");for(let i=0,d=e.children.length;i<d;i+=1)r.add(j(t,e.children[i]));return r.add(`</${o(t,n,{isClosing:!0})}>`),r}function j(t,e){let r=a(t,e),n=l.listItem;return r.add(`<${o(t,n)}`),e.spread!=null&&f(r,"spread",e.spread.toString()),e.checked!=null&&f(r,"checked",e.checked.toString()),r.add(">"),v(t,r,e.children),r.add(`</${o(t,n,{isClosing:!0})}>`),r}function V(t,e){let r=a(t,e),n=l.html;return r.add(`<${o(t,n)}>`),r.add(`{${S(e.value)}}`),r.add(`</${o(t,n,{isClosing:!0})}>`),r}function Z(t,e){let r=a(t,e),n=l.code;return r.add(`<${o(t,n)}`),e.lang&&m(r,"lang",e.lang),e.meta&&m(r,"meta",e.meta),r.add(">"),r.add(`{${S(e.value)}}`),r.add(`</${o(t,n,{isClosing:!0})}>`),r}function W(t,e){let r=a(t,e);return r.add(`<${o(t,l.definition)}`),y(r,e),k(r,e),r.add(" />"),r}function U(t,e){let r=a(t,e);return r.add(e.value),r}function Y(t,e){let r=a(t,e),n=l.emphasis;return r.add(`<${o(t,n)}>`),p(t,r,e.children),r.add(`</${o(t,n,{isClosing:!0})}>`),r}function G(t,e){let r=a(t,e),n=l.strong;return r.add(`<${o(t,n)}>`),p(t,r,e.children),r.add(`</${o(t,n,{isClosing:!0})}>`),r}function K(t,e){let r=a(t,e),n=l.inlineCode;return r.add(`<${o(t,n)}>`),r.add(`{${S(e.value)}}`),r.add(`</${o(t,n,{isClosing:!0})}>`),r}function x(t,e){let r=a(t,e);return r.add(`<${o(t,l.break)} />`),r}function Q(t,e){let r=a(t,e),n=l.link;return r.add(`<${o(t,n)}`),y(r,e),r.add(">"),p(t,r,e.children),r.add(`</${o(t,n,{isClosing:!0})}>`),r}function ee(t,e){let r=a(t,e);return r.add(`<${o(t,l.image)}`),y(r,e),O(r,e),r.add(" />"),r}function te(t,e){let r=a(t,e),n=l.linkReference;return r.add(`<${o(t,n)}`),J(r,e),r.add(">"),p(t,r,e.children),r.add(`</${o(t,n,{isClosing:!0})}>`),r}function re(t,e){let r=a(t,e);return r.add(`<${o(t,l.imageReference)}`),J(r,e),O(r,e),r.add(" />"),r}function ne(t,e){let r=a(t,e),n=l.footnoteDefinition;return r.add(`<${o(t,n)}`),k(r,e),r.add(">"),v(t,r,e.children),r.add(`</${o(t,n,{isClosing:!0})}>`),r}function oe(t,e){let r=a(t,e);return r.add(`<${o(t,l.footnoteReference)}`),k(r,e),r.add(" />"),r}function ie(t,e){let r=a(t,e),n=l.table;r.add(`<${o(t,n)}`),e.align!=null&&f(r,"align",JSON.stringify(e.align)),r.add(">");for(let i=0,d=e.children.length;i<d;i+=1)r.add(ae(t,e.children[i],i===0));return r.add(`</${o(t,n,{isClosing:!0})}>`),r}function ae(t,e,r){let n=a(t,e),i=l.tableRow;n.add(`<${o(t,i)}`),r&&f(n,"isHead","true"),n.add(">");for(let d=0,g=e.children.length;d<g;d+=1)n.add(se(t,e.children[d]));return n.add(`</${o(t,i,{isClosing:!0})}>`),n}function se(t,e){let r=a(t,e),n=l.tableCell;return r.add(`<${o(t,n)}>`),p(t,r,e.children),r.add(`</${o(t,n,{isClosing:!0})}>`),r}function le(t,e){let r=a(t,e),n=l.delete;return r.add(`<${o(t,n)}>`),p(t,r,e.children),r.add(`</${o(t,n,{isClosing:!0})}>`),r}function D(t,e){let r=a(t,e);return r.add(`{${e.value}}`),r}function w(t,e){var n,i,d,g,u,$,b,L;let r=a(t,e);if(e.name){let X=ce(t,e.name);r.add(`<${o(t,X,{isMDX:!0})}`);for(let R=0,ue=e.attributes.length;R<ue;R+=1){let c=e.attributes[R],h=new C((i=(n=c.position)==null?void 0:n.start.line)!=null?i:null,(g=(d=c.position)==null?void 0:d.start.column)!=null?g:null,t.source);if(c.type==="mdxJsxAttribute"){if(h.add(` ${c.name}`),c.value)if(typeof c.value=="string")h.add(`={${S(c.value)}}`);else{let A=new C(($=(u=c.value.position)==null?void 0:u.start.line)!=null?$:null,(L=(b=c.value.position)==null?void 0:b.start.column)!=null?L:null,t.source);A.add(c.value.value),h.add(["={",A,"}"])}}else h.add(` {...${c.value}}`);r.add(h)}r.add(">"),T(t,r,e.children),r.add(`</${o(t,X,{isClosing:!0,isMDX:!0})}>`)}else r.add("<>"),T(t,r,e.children),r.add("</>");return r}function fe(t,e){let r=a(t,e);return r.add(`${e.value}
-`),t.imports.push(r),new C}function pe(t,e){let r=a(t,e);return r.add(M.serialize(I.parse(e.value))),t.frontmatter=r,new C}function ge(t,e){let r=a(t,e);return r.add(M.serialize(B.parse(e.value))),t.frontmatter=r,new C}function Se(t,e){switch(e.type){case"blockquote":return q(t,e);case"code":return Z(t,e);case"heading":return z(t,e);case"html":return V(t,e);case"list":return H(t,e);case"mdxFlowExpression":return D(t,e);case"mdxJsxFlowElement":return w(t,e);case"paragraph":return _(t,e);case"table":return ie(t,e);case"thematicBreak":return P(t,e);case"definition":return W(t,e);case"footnoteDefinition":return ne(t,e);default:throw new Error("invariant")}}function Ce(t,e){switch(e.type){case"break":return x(t,e);case"delete":return le(t,e);case"emphasis":return Y(t,e);case"footnoteReference":return oe(t,e);case"html":return V(t,e);case"image":return ee(t,e);case"imageReference":return re(t,e);case"inlineCode":return K(t,e);case"mdxJsxTextElement":return w(t,e);case"mdxTextExpression":return D(t,e);case"strong":return G(t,e);case"text":return U(t,e);case"link":return Q(t,e);case"linkReference":return te(t,e);default:throw new Error("invariant")}}function p(t,e,r){for(let n=0,i=r.length;n<i;n+=1)e.add(Ce(t,r[n]))}function v(t,e,r){for(let n=0,i=r.length;n<i;n+=1)e.add(Se(t,r[n]))}function N(t,e){switch(e.type){case"root":return me(t,e);case"paragraph":return _(t,e);case"heading":return z(t,e);case"thematicBreak":return P(t,e);case"blockquote":return q(t,e);case"list":return H(t,e);case"listItem":return j(t,e);case"code":return Z(t,e);case"definition":return W(t,e);case"text":return U(t,e);case"emphasis":return Y(t,e);case"strong":return G(t,e);case"inlineCode":return K(t,e);case"break":return x(t,e);case"link":return Q(t,e);case"image":return ee(t,e);case"linkReference":return te(t,e);case"imageReference":return re(t,e);case"footnoteDefinition":return ne(t,e);case"footnoteReference":return oe(t,e);case"table":return ie(t,e);case"tableCell":return se(t,e);case"tableRow":return ae(t,e,!1);case"delete":return le(t,e);case"mdxTextExpression":case"mdxFlowExpression":return D(t,e);case"mdxJsxTextElement":case"mdxJsxFlowElement":return w(t,e);case"mdxjsEsm":return fe(t,e);case"yaml":return pe(t,e);case"toml":return ge(t,e);default:throw new Error("Invalid node type")}}function T(t,e,r){for(let n=0,i=r.length;n<i;n+=1)e.add(N(t,r[n]))}var E="_useMDX$";function He(t,e,r={}){let n=he(e,{extensions:[Te(),Me(),ye(["yaml","toml"])],mdastExtensions:[be(),ke(),Ne(["yaml","toml"])]}),i=Re(n),d={source:t,options:r,imports:[],frontmatter:void 0,slugger:new De},g=N(d,n),u=new $e(null,null,t);if(u.add(d.imports),d.frontmatter&&(u.add("export const frontmatter = "),u.add(d.frontmatter),u.add(`;
+`:return"\\n";case"\r":return"\\r";case"\b":return"\\b";case"	":return"\\t";case"\f":return"\\f";case"<":return"\\x3C";case"\u2028":return"\\u2028";case"\u2029":return"\\u2029";default:return}}function S(t){let e="",r=0,n;for(let i=0,d=t.length;i<d;i+=1)n=de(t[i]),n&&(e+=t.slice(r,i)+n,r=i+1);return r===0?e=t:e+=t.slice(r),`"${e}"`}function a(t,e){var n,i,d;let r=(n=e.position)==null?void 0:n.start.column;return new C((d=(i=e.position)==null?void 0:i.start.line)!=null?d:null,r!=null?r-1:null,t.source)}function m(t,e,r){t.add(` ${e}={${S(r)}}`)}function f(t,e,r){t.add(` ${e}={${r}}`)}function k(t,e){m(t,"identifier",e.identifier),e.label&&m(t,"label",e.label)}function y(t,e){m(t,"url",e.url),e.title&&m(t,"title",e.title)}function O(t,e){e.alt&&m(t,"alt",e.alt)}function J(t,e){k(t,e),m(t,"referenceType",e.referenceType)}function o(t,e,r={}){return t.options.noDynamicComponents==="only-mdx"&&r.isMDX||t.options.noDynamicComponents===!0?e:r.isClosing?"Dynamic":`Dynamic component={${e}}`}function ce(t,e){return t.options.noDynamicComponents?e:/^[a-zA-Z0-9]+(-[a-zA-Z0-9]+)+$/.test(e)?`_ctx$.components['${e}']`:/^[a-zA-Z0-9]+:[a-zA-Z0-9]+$/.test(e)?`_ctx$.components['${e}']`:`typeof ${e} === 'undefined' ? _ctx$.components.${e} : ${e}`}var s="_ctx$",l={blockquote:`${s}.builtins.Blockquote`,break:`${s}.builtins.Break`,code:`${s}.builtins.Code`,definition:`${s}.builtins.Definition`,delete:`${s}.builtins.Delete`,emphasis:`${s}.builtins.Emphasis`,footnoteDefinition:`${s}.builtins.FootnoteDefinition`,footnoteReference:`${s}.builtins.FootnoteReference`,heading:`${s}.builtins.Heading`,html:`${s}.builtins.HTML`,image:`${s}.builtins.Image`,imageReference:`${s}.builtins.ImageReference`,inlineCode:`${s}.builtins.InlineCode`,link:`${s}.builtins.Link`,linkReference:`${s}.builtins.LinkReference`,list:`${s}.builtins.List`,listItem:`${s}.builtins.ListItem`,paragraph:`${s}.builtins.Paragraph`,root:`${s}.builtins.Root`,strong:`${s}.builtins.Strong`,table:`${s}.builtins.Table`,tableCell:`${s}.builtins.TableCell`,tableRow:`${s}.builtins.TableRow`,thematicBreak:`${s}.builtins.ThematicBreak`};function me(t,e){let r=a(t,e),n=l.root;return r.add(`<${o(t,n)}>`),T(t,r,e.children),r.add(`</${o(t,n,{isClosing:!0})}>`),r}function _(t,e){let r=a(t,e),n=l.paragraph;return r.add(`<${o(t,n)}>`),p(t,r,e.children),r.add(`</${o(t,n,{isClosing:!0})}>`),r}function z(t,e){let r=a(t,e),n=l.heading,i=F.toString(e,{includeImageAlt:!1});return r.add(`<${o(t,n)}`),f(r,"depth",e.depth.toString()),m(r,"id",t.slugger.slug(i)),r.add(">"),p(t,r,e.children),r.add(`</${o(t,n,{isClosing:!0})}>`),r}function P(t,e){let r=a(t,e);return r.add(`<${o(t,l.thematicBreak)} />`),r}function q(t,e){let r=a(t,e),n=l.blockquote;return r.add(`<${o(t,n)}>`),v(t,r,e.children),r.add(`</${o(t,n,{isClosing:!0})}>`),r}function H(t,e){let r=a(t,e),n=l.list;r.add(`<${o(t,n)}`),e.ordered!=null&&f(r,"ordered",e.ordered.toString()),e.spread!=null&&f(r,"spread",e.spread.toString()),e.start!=null&&f(r,"start",e.start.toString()),r.add(">");for(let i=0,d=e.children.length;i<d;i+=1)r.add(j(t,e.children[i]));return r.add(`</${o(t,n,{isClosing:!0})}>`),r}function j(t,e){let r=a(t,e),n=l.listItem;return r.add(`<${o(t,n)}`),e.spread!=null&&f(r,"spread",e.spread.toString()),e.checked!=null&&f(r,"checked",e.checked.toString()),r.add(">"),v(t,r,e.children),r.add(`</${o(t,n,{isClosing:!0})}>`),r}function V(t,e){let r=a(t,e),n=l.html;return r.add(`<${o(t,n)}>`),r.add(`{${S(e.value)}}`),r.add(`</${o(t,n,{isClosing:!0})}>`),r}function Z(t,e){let r=a(t,e),n=l.code;return r.add(`<${o(t,n)}`),e.lang&&m(r,"lang",e.lang),e.meta&&m(r,"meta",e.meta),r.add(">"),r.add(`{${S(e.value)}}`),r.add(`</${o(t,n,{isClosing:!0})}>`),r}function W(t,e){let r=a(t,e);return r.add(`<${o(t,l.definition)}`),y(r,e),k(r,e),r.add(" />"),r}function U(t,e){let r=a(t,e);return r.add(e.value),r}function Y(t,e){let r=a(t,e),n=l.emphasis;return r.add(`<${o(t,n)}>`),p(t,r,e.children),r.add(`</${o(t,n,{isClosing:!0})}>`),r}function G(t,e){let r=a(t,e),n=l.strong;return r.add(`<${o(t,n)}>`),p(t,r,e.children),r.add(`</${o(t,n,{isClosing:!0})}>`),r}function K(t,e){let r=a(t,e),n=l.inlineCode;return r.add(`<${o(t,n)}>`),r.add(`{${S(e.value)}}`),r.add(`</${o(t,n,{isClosing:!0})}>`),r}function x(t,e){let r=a(t,e);return r.add(`<${o(t,l.break)} />`),r}function Q(t,e){let r=a(t,e),n=l.link;return r.add(`<${o(t,n)}`),y(r,e),r.add(">"),p(t,r,e.children),r.add(`</${o(t,n,{isClosing:!0})}>`),r}function ee(t,e){let r=a(t,e);return r.add(`<${o(t,l.image)}`),y(r,e),O(r,e),r.add(" />"),r}function te(t,e){let r=a(t,e),n=l.linkReference;return r.add(`<${o(t,n)}`),J(r,e),r.add(">"),p(t,r,e.children),r.add(`</${o(t,n,{isClosing:!0})}>`),r}function re(t,e){let r=a(t,e);return r.add(`<${o(t,l.imageReference)}`),J(r,e),O(r,e),r.add(" />"),r}function ne(t,e){let r=a(t,e),n=l.footnoteDefinition;return r.add(`<${o(t,n)}`),k(r,e),r.add(">"),v(t,r,e.children),r.add(`</${o(t,n,{isClosing:!0})}>`),r}function oe(t,e){let r=a(t,e);return r.add(`<${o(t,l.footnoteReference)}`),k(r,e),r.add(" />"),r}function ie(t,e){let r=a(t,e),n=l.table;r.add(`<${o(t,n)}`),e.align!=null&&f(r,"align",JSON.stringify(e.align)),r.add(">");for(let i=0,d=e.children.length;i<d;i+=1)r.add(ae(t,e.children[i],i===0));return r.add(`</${o(t,n,{isClosing:!0})}>`),r}function ae(t,e,r){let n=a(t,e),i=l.tableRow;n.add(`<${o(t,i)}`),r&&f(n,"isHead","true"),n.add(">");for(let d=0,g=e.children.length;d<g;d+=1)n.add(se(t,e.children[d]));return n.add(`</${o(t,i,{isClosing:!0})}>`),n}function se(t,e){let r=a(t,e),n=l.tableCell;return r.add(`<${o(t,n)}>`),p(t,r,e.children),r.add(`</${o(t,n,{isClosing:!0})}>`),r}function le(t,e){let r=a(t,e),n=l.delete;return r.add(`<${o(t,n)}>`),p(t,r,e.children),r.add(`</${o(t,n,{isClosing:!0})}>`),r}function D(t,e){let r=a(t,e);return r.add(`{${e.value}}`),r}function w(t,e){var n,i,d,g,u,$,b,L;let r=a(t,e);if(e.name){let X=ce(t,e.name);r.add(`<${o(t,X,{isMDX:!0})}`);for(let R=0,ue=e.attributes.length;R<ue;R+=1){let c=e.attributes[R],h=new C((i=(n=c.position)==null?void 0:n.start.line)!=null?i:null,(g=(d=c.position)==null?void 0:d.start.column)!=null?g:null,t.source);if(c.type==="mdxJsxAttribute"){if(h.add(` ${c.name}`),c.value)if(typeof c.value=="string")h.add(`={${S(c.value)}}`);else{let A=new C(($=(u=c.value.position)==null?void 0:u.start.line)!=null?$:null,(L=(b=c.value.position)==null?void 0:b.start.column)!=null?L:null,t.source);A.add(c.value.value),h.add(["={",A,"}"])}}else h.add(` {...${c.value}}`);r.add(h)}r.add(">"),T(t,r,e.children),r.add(`</${o(t,X,{isClosing:!0,isMDX:!0})}>`)}else r.add("<>"),T(t,r,e.children),r.add("</>");return r}function fe(t,e){let r=a(t,e);return r.add(`${e.value}
+`),t.imports.push(r),new C}function pe(t,e){let r=a(t,e);return r.add(M.serialize(I.parse(e.value))),t.frontmatter=r,new C}function ge(t,e){let r=a(t,e);return r.add(M.serialize(B.parse(e.value))),t.frontmatter=r,new C}function Se(t,e){switch(e.type){case"blockquote":return q(t,e);case"code":return Z(t,e);case"heading":return z(t,e);case"html":return V(t,e);case"list":return H(t,e);case"mdxFlowExpression":return D(t,e);case"mdxJsxFlowElement":return w(t,e);case"paragraph":return _(t,e);case"table":return ie(t,e);case"thematicBreak":return P(t,e);case"definition":return W(t,e);case"footnoteDefinition":return ne(t,e);default:throw new Error("invariant")}}function Ce(t,e){switch(e.type){case"break":return x(t,e);case"delete":return le(t,e);case"emphasis":return Y(t,e);case"footnoteReference":return oe(t,e);case"html":return V(t,e);case"image":return ee(t,e);case"imageReference":return re(t,e);case"inlineCode":return K(t,e);case"mdxJsxTextElement":return w(t,e);case"mdxTextExpression":return D(t,e);case"strong":return G(t,e);case"text":return U(t,e);case"link":return Q(t,e);case"linkReference":return te(t,e);default:throw new Error("invariant")}}function p(t,e,r){for(let n=0,i=r.length;n<i;n+=1)e.add(Ce(t,r[n]))}function v(t,e,r){for(let n=0,i=r.length;n<i;n+=1)e.add(Se(t,r[n]))}function N(t,e){switch(e.type){case"root":return me(t,e);case"paragraph":return _(t,e);case"heading":return z(t,e);case"thematicBreak":return P(t,e);case"blockquote":return q(t,e);case"list":return H(t,e);case"listItem":return j(t,e);case"code":return Z(t,e);case"definition":return W(t,e);case"text":return U(t,e);case"emphasis":return Y(t,e);case"strong":return G(t,e);case"inlineCode":return K(t,e);case"break":return x(t,e);case"link":return Q(t,e);case"image":return ee(t,e);case"linkReference":return te(t,e);case"imageReference":return re(t,e);case"footnoteDefinition":return ne(t,e);case"footnoteReference":return oe(t,e);case"table":return ie(t,e);case"tableCell":return se(t,e);case"tableRow":return ae(t,e,!1);case"delete":return le(t,e);case"mdxTextExpression":case"mdxFlowExpression":return D(t,e);case"mdxJsxTextElement":case"mdxJsxFlowElement":return w(t,e);case"mdxjsEsm":return fe(t,e);case"yaml":return pe(t,e);case"toml":return ge(t,e);default:throw new Error("Invalid node type")}}function T(t,e,r){for(let n=0,i=r.length;n<i;n+=1)e.add(N(t,r[n]))}var E="_useMDX$";function He(t,e,r={}){let n=he(e,{extensions:[Te(),Me(),ye(["yaml","toml"])],mdastExtensions:[be(),ke(),Ne(["yaml","toml"])]}),i=Re(n,{parents:()=>true}),d={source:t,options:r,imports:[],frontmatter:void 0,slugger:new De},g=N(d,n),u=new $e(null,null,t);if(u.add(d.imports),d.frontmatter&&(u.add("export const frontmatter = "),u.add(d.frontmatter),u.add(`;
 `)),u.add(`import { useMDX as ${E} } from '${r.mdxImportSource||"solid-marked"}';
 
 `),i.map){let b=N(d,i.map);u.add(`export function TableOfContents(props) {